# SoybeanAdmin NestJS ä½ä»£ç å¹³å°åŠŸèƒ½è®¾è®¡

## ğŸ¯ å¹³å°æ¦‚è§ˆ

### æ ¸å¿ƒå®šä½
SoybeanAdmin NestJS çš„ä½ä»£ç å¹³å°æ˜¯ä¸€ä¸ªé¢å‘å¼€å‘è€…çš„**å¯è§†åŒ–åç«¯å¼€å‘å¹³å°**ï¼Œä¸“æ³¨äºå¿«é€Ÿç”Ÿæˆä¼ä¸šçº§CRUDåº”ç”¨å’ŒAPIæœåŠ¡ã€‚

### ä»·å€¼ä¸»å¼ 
- **æå‡å¼€å‘æ•ˆç‡**: å‡å°‘80%çš„é‡å¤ç¼–ç å·¥ä½œ
- **ä¿è¯ä»£ç è´¨é‡**: åŸºäºæœ€ä½³å®è·µçš„ä»£ç æ¨¡æ¿
- **é™ä½æŠ€æœ¯é—¨æ§›**: ä¸šåŠ¡äººå‘˜ä¹Ÿèƒ½å‚ä¸ç³»ç»Ÿè®¾è®¡
- **ç¡®ä¿å¯ç»´æŠ¤æ€§**: ç”Ÿæˆæ¸…æ™°ã€æ˜“æ‰©å±•çš„ä»£ç 

## ğŸ—ï¸ å¹³å°æ¶æ„

### æ ¸å¿ƒç»„ä»¶
```
ğŸ“Š å¯è§†åŒ–è®¾è®¡å±‚
â”œâ”€â”€ å®ä½“å…³ç³»è®¾è®¡å™¨ (AntV X6)
â”œâ”€â”€ APIé…ç½®å™¨
â”œâ”€â”€ æŸ¥è¯¢æ„å»ºå™¨
â””â”€â”€ æ¨¡æ¿ç¼–è¾‘å™¨

âš™ï¸ å¹³å°å¼•æ“å±‚  
â”œâ”€â”€ é¡¹ç›®ç®¡ç†å¼•æ“
â”œâ”€â”€ å…ƒæ•°æ®ç®¡ç†å¼•æ“
â”œâ”€â”€ ä»£ç ç”Ÿæˆå¼•æ“
â””â”€â”€ éƒ¨ç½²å¼•æ“

ğŸ”§ ä»£ç ç”Ÿæˆå±‚
â”œâ”€â”€ å®ä½“ä»£ç ç”Ÿæˆ
â”œâ”€â”€ APIä»£ç ç”Ÿæˆ
â”œâ”€â”€ ä¸šåŠ¡é€»è¾‘ç”Ÿæˆ
â””â”€â”€ æµ‹è¯•ä»£ç ç”Ÿæˆ

ğŸš€ è¿è¡Œæ—¶å±‚
â”œâ”€â”€ åŠ¨æ€APIæœåŠ¡
â”œâ”€â”€ ä¸šåŠ¡æ•°æ®æœåŠ¡
â””â”€â”€ æƒé™éªŒè¯æœåŠ¡
```

## ğŸ“Š é¡¹ç›®ç®¡ç†åŠŸèƒ½

### é¡¹ç›®é…ç½®ç»“æ„
```typescript
interface ProjectConfig {
  // åŸºç¡€ä¿¡æ¯
  name: string;
  code: string;
  description?: string;
  version: string;
  
  // æŠ€æœ¯æ¶æ„
  framework: 'nestjs' | 'express';
  architecture: 'mvc' | 'ddd' | 'cqrs';
  language: 'typescript' | 'javascript';
  database: 'postgresql' | 'mysql' | 'mongodb';
  
  // åŠŸèƒ½ç‰¹æ€§
  features: {
    authentication: boolean;    // è®¤è¯åŠŸèƒ½
    authorization: boolean;     // æˆæƒåŠŸèƒ½
    caching: boolean;          // ç¼“å­˜åŠŸèƒ½
    swagger: boolean;          // APIæ–‡æ¡£
    testing: boolean;          // å•å…ƒæµ‹è¯•
    docker: boolean;           // Dockeræ”¯æŒ
  };
  
  // å¼€å‘è®¾ç½®
  settings: {
    enableSoftDelete: boolean;  // è½¯åˆ é™¤
    enableAuditFields: boolean; // å®¡è®¡å­—æ®µ
    enableVersioning: boolean;  // ç‰ˆæœ¬æ§åˆ¶
    enableTenancy: boolean;     // å¤šç§Ÿæˆ·
  };
}
```

### é¡¹ç›®çŠ¶æ€ç®¡ç†
```typescript
enum ProjectStatus {
  DRAFT = 'DRAFT',           // è‰ç¨¿çŠ¶æ€
  ACTIVE = 'ACTIVE',         // æ´»è·ƒå¼€å‘
  DEPLOYED = 'DEPLOYED',     // å·²éƒ¨ç½²
  ARCHIVED = 'ARCHIVED'      // å·²å½’æ¡£
}

enum DeploymentStatus {
  INACTIVE = 'INACTIVE',     // æœªéƒ¨ç½²
  DEPLOYING = 'DEPLOYING',   // éƒ¨ç½²ä¸­
  DEPLOYED = 'DEPLOYED',     // å·²éƒ¨ç½²
  FAILED = 'FAILED'          // éƒ¨ç½²å¤±è´¥
}
```

## ğŸ¨ å®ä½“å…³ç³»è®¾è®¡å™¨

### å®ä½“å»ºæ¨¡
```typescript
interface EntityDefinition {
  id: string;
  name: string;              // ä¸­æ–‡åç§°
  code: string;              // è‹±æ–‡ç¼–ç 
  tableName: string;         // æ•°æ®åº“è¡¨å
  description?: string;
  category?: string;
  
  // å¯è§†åŒ–ä½ç½®
  diagramPosition?: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  
  // ä¸šåŠ¡é…ç½®
  config: {
    enableSoftDelete: boolean;
    enableAuditFields: boolean;
    enableVersioning: boolean;
    cacheable: boolean;
    searchable: boolean;
  };
  
  fields: FieldDefinition[];
  relationships: RelationshipDefinition[];
}
```

### å­—æ®µç±»å‹ç³»ç»Ÿ
```typescript
enum FieldType {
  // åŸºç¡€ç±»å‹
  STRING = 'STRING',
  TEXT = 'TEXT',
  INTEGER = 'INTEGER',
  DECIMAL = 'DECIMAL',
  BOOLEAN = 'BOOLEAN',
  DATE = 'DATE',
  DATETIME = 'DATETIME',
  
  // ç‰¹æ®Šç±»å‹
  JSON = 'JSON',
  ARRAY = 'ARRAY',
  ENUM = 'ENUM',
  UUID = 'UUID',
  FILE = 'FILE',
  IMAGE = 'IMAGE',
  
  // å¼•ç”¨ç±»å‹
  REFERENCE = 'REFERENCE'
}

interface FieldDefinition {
  id: string;
  name: string;              // å­—æ®µä¸­æ–‡å
  code: string;              // å­—æ®µè‹±æ–‡å
  type: FieldType;
  
  // ç±»å‹å‚æ•°
  length?: number;
  precision?: number;
  scale?: number;
  
  // çº¦æŸé…ç½®
  nullable: boolean;
  unique: boolean;
  primaryKey: boolean;
  indexed: boolean;
  
  // éªŒè¯è§„åˆ™
  defaultValue?: any;
  validationRules: ValidationRule[];
  
  // æ˜¾ç¤ºé…ç½®
  displayConfig: {
    showInList: boolean;
    showInForm: boolean;
    showInDetail: boolean;
    sortable: boolean;
    filterable: boolean;
    searchable: boolean;
  };
}
```

### å…³ç³»ç®¡ç†
```typescript
enum RelationshipType {
  ONE_TO_ONE = 'oneToOne',
  ONE_TO_MANY = 'oneToMany',
  MANY_TO_ONE = 'manyToOne',
  MANY_TO_MANY = 'manyToMany'
}

interface RelationshipDefinition {
  id: string;
  name: string;
  code: string;
  type: RelationshipType;
  
  source: {
    entityId: string;
    fieldId?: string;
    propertyName: string;
    optional: boolean;
  };
  
  target: {
    entityId: string;
    fieldId?: string;
    propertyName: string;
    optional: boolean;
  };
  
  // æ•°æ®åº“é…ç½®
  database: {
    foreignKeyName?: string;
    joinTable?: {            // å¤šå¯¹å¤šè¿æ¥è¡¨
      name: string;
      sourceColumn: string;
      targetColumn: string;
    };
    onDelete: 'CASCADE' | 'RESTRICT' | 'SET_NULL';
    onUpdate: 'CASCADE' | 'RESTRICT' | 'SET_NULL';
  };
}
```

## ğŸ”§ APIè‡ªåŠ¨ç”Ÿæˆ

### RESTful APIæ¨¡æ¿
```typescript
interface ApiTemplate {
  entityOperations: {
    create: boolean;           // POST /entities
    findAll: boolean;          // GET /entities
    findOne: boolean;          // GET /entities/:id
    update: boolean;           // PUT /entities/:id
    delete: boolean;           // DELETE /entities/:id
    bulkCreate: boolean;       // POST /entities/bulk
    bulkUpdate: boolean;       // PUT /entities/bulk
    bulkDelete: boolean;       // DELETE /entities/bulk
    search: boolean;           // GET /entities/search
    count: boolean;            // GET /entities/count
  };
  
  queryFeatures: {
    pagination: boolean;       // åˆ†é¡µæ”¯æŒ
    sorting: boolean;          // æ’åºæ”¯æŒ
    filtering: boolean;        // è¿‡æ»¤æ”¯æŒ
    searching: boolean;        // æœç´¢æ”¯æŒ
    relations: boolean;        // å…³è”æ•°æ®
  };
  
  responseFormat: {
    wrapper: boolean;          // å“åº”åŒ…è£…
    metadata: boolean;         // å…ƒæ•°æ®ä¿¡æ¯
    timestamps: boolean;       // æ—¶é—´æˆ³
  };
}
```

### æ§åˆ¶å™¨ä»£ç ç”Ÿæˆç¤ºä¾‹
```typescript
// è‡ªåŠ¨ç”Ÿæˆçš„Controller
@Controller('users')
@ApiTags('ç”¨æˆ·ç®¡ç†')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  @ApiOperation({ summary: 'åˆ›å»ºç”¨æˆ·' })
  async create(@Body() createUserDto: CreateUserDto) {
    return this.userService.create(createUserDto);
  }

  @Get()
  @ApiOperation({ summary: 'è·å–ç”¨æˆ·åˆ—è¡¨' })
  async findAll(@Query() query: FindAllUsersDto) {
    return this.userService.findAll(query);
  }

  @Get(':id')
  @ApiOperation({ summary: 'è·å–ç”¨æˆ·è¯¦æƒ…' })
  async findOne(@Param('id') id: string) {
    return this.userService.findOne(id);
  }
}
```

## ğŸ” æŸ¥è¯¢æ„å»ºå™¨

### å¯è§†åŒ–æŸ¥è¯¢è®¾è®¡
```typescript
interface QueryDefinition {
  id: string;
  name: string;
  description?: string;
  
  // ä¸»è¡¨é…ç½®
  baseEntity: {
    entityId: string;
    alias: string;
  };
  
  // è¿æ¥é…ç½®
  joins: JoinDefinition[];
  
  // å­—æ®µé€‰æ‹©
  select: SelectField[];
  
  // æ¡ä»¶é…ç½®
  where: WhereCondition[];
  
  // æ’åºé…ç½®
  orderBy: OrderByField[];
  
  // åˆ†ç»„é…ç½®
  groupBy: GroupByField[];
  having: HavingCondition[];
  
  // åˆ†é¡µé…ç½®
  pagination: {
    enabled: boolean;
    defaultSize: number;
    maxSize: number;
  };
}

interface WhereCondition {
  logic: 'AND' | 'OR';
  field: string;
  operator: ComparisonOperator;  // equals, gt, lt, like, in, betweenç­‰
  value: any;
  dataType: FieldType;
}
```

### SQLç”Ÿæˆå¼•æ“
```typescript
@Injectable()
export class QueryBuilderService {
  async executeQuery(queryDef: QueryDefinition, params: any = {}) {
    // æ„å»ºSQLæŸ¥è¯¢
    const sql = this.buildSQLFromDefinition(queryDef, params);
    
    // æ‰§è¡ŒæŸ¥è¯¢
    const result = await this.prismaService.$queryRaw(sql);
    
    return this.processQueryResult(result, queryDef);
  }

  private buildSQLFromDefinition(queryDef: QueryDefinition, params: any): string {
    const { baseEntity, joins, select, where, orderBy } = queryDef;
    
    // æ„å»ºSELECTã€FROMã€JOINã€WHEREã€ORDER BYå­å¥
    const selectClause = this.buildSelectClause(select);
    const fromClause = `FROM ${baseEntity.entityId} AS ${baseEntity.alias}`;
    const joinClause = joins.map(join => this.buildJoinClause(join)).join(' ');
    const whereClause = where.length > 0 ? 
      `WHERE ${this.buildWhereClause(where, params)}` : '';
    const orderByClause = orderBy.length > 0 ? 
      `ORDER BY ${orderBy.map(o => `${o.entityAlias}.${o.fieldCode} ${o.direction}`).join(', ')}` : '';
    
    return [selectClause, fromClause, joinClause, whereClause, orderByClause]
      .filter(Boolean).join(' ');
  }
}
```

## ğŸ› ï¸ ä»£ç ç”Ÿæˆå¼•æ“

### æ¨¡æ¿ç³»ç»Ÿ
```typescript
interface CodeTemplate {
  id: string;
  name: string;
  code: string;
  type: TemplateType;          // entity, dto, service, controllerç­‰
  category: TemplateCategory;
  
  // æŠ€æœ¯é…ç½®
  language: 'typescript' | 'javascript';
  framework: 'nestjs' | 'express';
  
  // æ¨¡æ¿å†…å®¹(Handlebarsæ ¼å¼)
  content: string;
  
  // å˜é‡å®šä¹‰
  variables: TemplateVariable[];
  
  // è¾“å‡ºé…ç½®
  output: {
    filename: string;          // è¾“å‡ºæ–‡ä»¶åæ¨¡æ¿
    directory: string;         // è¾“å‡ºç›®å½•æ¨¡æ¿
    extension: string;         // æ–‡ä»¶æ‰©å±•å
  };
  
  dependencies: string[];      // ä¾èµ–çš„å…¶ä»–æ¨¡æ¿
  version: string;
}

enum TemplateType {
  ENTITY = 'entity',
  DTO = 'dto',
  SERVICE = 'service',
  CONTROLLER = 'controller',
  MODULE = 'module',
  TEST = 'test',
  CONFIG = 'config'
}
```

### ä»£ç ç”Ÿæˆæµç¨‹
```typescript
@Injectable()
export class CodeGenerationService {
  async generateProject(projectId: string, options: GenerationOptions): Promise<GenerationResult> {
    // åˆ›å»ºç”Ÿæˆä»»åŠ¡
    const task = await this.createGenerationTask(projectId, options);
    
    try {
      // è·å–é¡¹ç›®å…ƒæ•°æ®
      const metadata = await this.getProjectMetadata(projectId);
      
      // ç”Ÿæˆä»£ç æ–‡ä»¶
      const files = await this.generateCodeFiles(metadata, options);
      
      // éªŒè¯ç”Ÿæˆçš„ä»£ç 
      const validation = await this.validateGeneratedCode(files);
      
      // ä¿å­˜åˆ°æ–‡ä»¶ç³»ç»Ÿ
      const output = await this.saveGeneratedFiles(files, options.outputPath);
      
      return { taskId: task.id, files, output, validation };
      
    } catch (error) {
      await this.updateTaskStatus(task.id, 'FAILED', { error: error.message });
      throw error;
    }
  }

  private async generateCodeFiles(metadata: ProjectMetadata, options: GenerationOptions): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    // ä¸ºæ¯ä¸ªå®ä½“ç”Ÿæˆä»£ç æ–‡ä»¶
    for (const entity of metadata.entities) {
      files.push(...await this.generateEntityFiles(entity, options));
    }
    
    // ç”Ÿæˆæ¨¡å—æ–‡ä»¶
    files.push(await this.generateAppModule(metadata, options));
    
    // ç”Ÿæˆé…ç½®æ–‡ä»¶
    files.push(...await this.generateConfigFiles(metadata, options));
    
    return files;
  }
}
```

## ğŸš€ éƒ¨ç½²ä¸è¿è¡Œæ—¶

### åŠ¨æ€éƒ¨ç½²å¼•æ“
```typescript
@Injectable()
export class DeploymentService {
  async deployProject(projectId: string): Promise<DeploymentResult> {
    try {
      // 1. ç”Ÿæˆä»£ç 
      await this.generateProjectCode(projectId);
      
      // 2. å®‰è£…ä¾èµ–
      await this.installDependencies(projectId);
      
      // 3. æ„å»ºé¡¹ç›®
      await this.buildProject(projectId);
      
      // 4. å¯åŠ¨æœåŠ¡
      const port = await this.startService(projectId);
      
      // 5. æ›´æ–°éƒ¨ç½²çŠ¶æ€
      await this.updateDeploymentStatus(projectId, 'DEPLOYED', port);
      
      return {
        status: 'success',
        port,
        url: `http://localhost:${port}`
      };
      
    } catch (error) {
      await this.updateDeploymentStatus(projectId, 'FAILED');
      throw error;
    }
  }

  private async startService(projectId: string): Promise<number> {
    const port = await this.findAvailablePort();
    
    // å¯åŠ¨Node.jsè¿›ç¨‹
    const child = spawn('npm', ['run', 'start:prod'], {
      cwd: this.getProjectPath(projectId),
      env: { ...process.env, PORT: port.toString() },
      detached: true,
      stdio: 'pipe'
    });
    
    // å­˜å‚¨è¿›ç¨‹ä¿¡æ¯
    this.activeProcesses.set(projectId, {
      pid: child.pid,
      port,
      startTime: Date.now()
    });
    
    return port;
  }
}
```

### è¿è¡Œæ—¶ç®¡ç†
```typescript
@Injectable()
export class RuntimeService {
  private activeProcesses = new Map<string, ProcessInfo>();

  async getProjectStatus(projectId: string): Promise<ProjectStatus> {
    const process = this.activeProcesses.get(projectId);
    
    if (!process) {
      return { status: 'stopped' };
    }
    
    // æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ
    const isRunning = await this.checkProcessHealth(process);
    
    return {
      status: isRunning ? 'running' : 'stopped',
      port: process.port,
      uptime: Date.now() - process.startTime,
      pid: process.pid
    };
  }

  async stopProject(projectId: string): Promise<void> {
    const process = this.activeProcesses.get(projectId);
    
    if (process) {
      // ä¼˜é›…å…³é—­è¿›ç¨‹
      process.kill('SIGTERM');
      
      // ç­‰å¾…è¿›ç¨‹å…³é—­
      await this.waitForProcessExit(process.pid);
      
      this.activeProcesses.delete(projectId);
    }
  }
}
```

## ğŸ“Š å¹³å°ç‰¹è‰²åŠŸèƒ½

### å®æ—¶ä»£ç é¢„è§ˆ
- **å³æ—¶ç”Ÿæˆ**: é…ç½®å˜æ›´å®æ—¶ç”Ÿæˆä»£ç é¢„è§ˆ
- **è¯­æ³•é«˜äº®**: æ”¯æŒTypeScriptè¯­æ³•é«˜äº®æ˜¾ç¤º
- **æ–‡ä»¶æ ‘**: æ˜¾ç¤ºå®Œæ•´çš„é¡¹ç›®æ–‡ä»¶ç»“æ„
- **å·®å¼‚å¯¹æ¯”**: é…ç½®å˜æ›´å‰åçš„ä»£ç å·®å¼‚

### æ™ºèƒ½éªŒè¯ç³»ç»Ÿ
- **è¯­æ³•éªŒè¯**: è‡ªåŠ¨æ£€æŸ¥ç”Ÿæˆä»£ç çš„è¯­æ³•æ­£ç¡®æ€§
- **ä¾èµ–æ£€æŸ¥**: éªŒè¯æ¨¡å—é—´ä¾èµ–å…³ç³»
- **è§„èŒƒæ£€æŸ¥**: ä»£ç é£æ ¼å’Œå‘½åè§„èŒƒæ£€æŸ¥
- **æ€§èƒ½åˆ†æ**: ç”Ÿæˆä»£ç çš„æ€§èƒ½è¯„ä¼°

### ç‰ˆæœ¬ç®¡ç†
- **æ¨¡æ¿ç‰ˆæœ¬**: æ”¯æŒæ¨¡æ¿çš„ç‰ˆæœ¬ç®¡ç†å’Œå›æ»š
- **é¡¹ç›®ç‰ˆæœ¬**: é¡¹ç›®é…ç½®çš„ç‰ˆæœ¬æ§åˆ¶
- **ä»£ç ç‰ˆæœ¬**: ç”Ÿæˆä»£ç çš„ç‰ˆæœ¬è¿½è¸ª
- **å˜æ›´æ—¥å¿—**: è¯¦ç»†çš„å˜æ›´å†å²è®°å½•

### æ‰©å±•æœºåˆ¶
- **è‡ªå®šä¹‰æ¨¡æ¿**: æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰ä»£ç æ¨¡æ¿
- **æ’ä»¶ç³»ç»Ÿ**: æ”¯æŒåŠŸèƒ½æ’ä»¶æ‰©å±•
- **é’©å­å‡½æ•°**: ä»£ç ç”Ÿæˆè¿‡ç¨‹çš„é’©å­å‡½æ•°
- **APIå¼€æ”¾**: æä¾›å®Œæ•´çš„å¹³å°APIæ¥å£

è¿™ä¸ªä½ä»£ç å¹³å°é€šè¿‡å¯è§†åŒ–å»ºæ¨¡ã€æ™ºèƒ½ä»£ç ç”Ÿæˆå’Œè‡ªåŠ¨åŒ–éƒ¨ç½²ï¼Œå¤§å¤§æå‡äº†åç«¯å¼€å‘çš„æ•ˆç‡å’Œè´¨é‡ï¼Œæ˜¯ç°ä»£ä¼ä¸šçº§åº”ç”¨å¼€å‘çš„æœ‰åŠ›å·¥å…·ã€‚