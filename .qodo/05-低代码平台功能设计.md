# SoybeanAdmin NestJS 低代码平台功能设计

## 🎯 平台概览

### 核心定位
SoybeanAdmin NestJS 的低代码平台是一个面向开发者的**可视化后端开发平台**，专注于快速生成企业级CRUD应用和API服务。

### 价值主张
- **提升开发效率**: 减少80%的重复编码工作
- **保证代码质量**: 基于最佳实践的代码模板
- **降低技术门槛**: 业务人员也能参与系统设计
- **确保可维护性**: 生成清晰、易扩展的代码

## 🏗️ 平台架构

### 核心组件
```
📊 可视化设计层
├── 实体关系设计器 (AntV X6)
├── API配置器
├── 查询构建器
└── 模板编辑器

⚙️ 平台引擎层  
├── 项目管理引擎
├── 元数据管理引擎
├── 代码生成引擎
└── 部署引擎

🔧 代码生成层
├── 实体代码生成
├── API代码生成
├── 业务逻辑生成
└── 测试代码生成

🚀 运行时层
├── 动态API服务
├── 业务数据服务
└── 权限验证服务
```

## 📊 项目管理功能

### 项目配置结构
```typescript
interface ProjectConfig {
  // 基础信息
  name: string;
  code: string;
  description?: string;
  version: string;
  
  // 技术架构
  framework: 'nestjs' | 'express';
  architecture: 'mvc' | 'ddd' | 'cqrs';
  language: 'typescript' | 'javascript';
  database: 'postgresql' | 'mysql' | 'mongodb';
  
  // 功能特性
  features: {
    authentication: boolean;    // 认证功能
    authorization: boolean;     // 授权功能
    caching: boolean;          // 缓存功能
    swagger: boolean;          // API文档
    testing: boolean;          // 单元测试
    docker: boolean;           // Docker支持
  };
  
  // 开发设置
  settings: {
    enableSoftDelete: boolean;  // 软删除
    enableAuditFields: boolean; // 审计字段
    enableVersioning: boolean;  // 版本控制
    enableTenancy: boolean;     // 多租户
  };
}
```

### 项目状态管理
```typescript
enum ProjectStatus {
  DRAFT = 'DRAFT',           // 草稿状态
  ACTIVE = 'ACTIVE',         // 活跃开发
  DEPLOYED = 'DEPLOYED',     // 已部署
  ARCHIVED = 'ARCHIVED'      // 已归档
}

enum DeploymentStatus {
  INACTIVE = 'INACTIVE',     // 未部署
  DEPLOYING = 'DEPLOYING',   // 部署中
  DEPLOYED = 'DEPLOYED',     // 已部署
  FAILED = 'FAILED'          // 部署失败
}
```

## 🎨 实体关系设计器

### 实体建模
```typescript
interface EntityDefinition {
  id: string;
  name: string;              // 中文名称
  code: string;              // 英文编码
  tableName: string;         // 数据库表名
  description?: string;
  category?: string;
  
  // 可视化位置
  diagramPosition?: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  
  // 业务配置
  config: {
    enableSoftDelete: boolean;
    enableAuditFields: boolean;
    enableVersioning: boolean;
    cacheable: boolean;
    searchable: boolean;
  };
  
  fields: FieldDefinition[];
  relationships: RelationshipDefinition[];
}
```

### 字段类型系统
```typescript
enum FieldType {
  // 基础类型
  STRING = 'STRING',
  TEXT = 'TEXT',
  INTEGER = 'INTEGER',
  DECIMAL = 'DECIMAL',
  BOOLEAN = 'BOOLEAN',
  DATE = 'DATE',
  DATETIME = 'DATETIME',
  
  // 特殊类型
  JSON = 'JSON',
  ARRAY = 'ARRAY',
  ENUM = 'ENUM',
  UUID = 'UUID',
  FILE = 'FILE',
  IMAGE = 'IMAGE',
  
  // 引用类型
  REFERENCE = 'REFERENCE'
}

interface FieldDefinition {
  id: string;
  name: string;              // 字段中文名
  code: string;              // 字段英文名
  type: FieldType;
  
  // 类型参数
  length?: number;
  precision?: number;
  scale?: number;
  
  // 约束配置
  nullable: boolean;
  unique: boolean;
  primaryKey: boolean;
  indexed: boolean;
  
  // 验证规则
  defaultValue?: any;
  validationRules: ValidationRule[];
  
  // 显示配置
  displayConfig: {
    showInList: boolean;
    showInForm: boolean;
    showInDetail: boolean;
    sortable: boolean;
    filterable: boolean;
    searchable: boolean;
  };
}
```

### 关系管理
```typescript
enum RelationshipType {
  ONE_TO_ONE = 'oneToOne',
  ONE_TO_MANY = 'oneToMany',
  MANY_TO_ONE = 'manyToOne',
  MANY_TO_MANY = 'manyToMany'
}

interface RelationshipDefinition {
  id: string;
  name: string;
  code: string;
  type: RelationshipType;
  
  source: {
    entityId: string;
    fieldId?: string;
    propertyName: string;
    optional: boolean;
  };
  
  target: {
    entityId: string;
    fieldId?: string;
    propertyName: string;
    optional: boolean;
  };
  
  // 数据库配置
  database: {
    foreignKeyName?: string;
    joinTable?: {            // 多对多连接表
      name: string;
      sourceColumn: string;
      targetColumn: string;
    };
    onDelete: 'CASCADE' | 'RESTRICT' | 'SET_NULL';
    onUpdate: 'CASCADE' | 'RESTRICT' | 'SET_NULL';
  };
}
```

## 🔧 API自动生成

### RESTful API模板
```typescript
interface ApiTemplate {
  entityOperations: {
    create: boolean;           // POST /entities
    findAll: boolean;          // GET /entities
    findOne: boolean;          // GET /entities/:id
    update: boolean;           // PUT /entities/:id
    delete: boolean;           // DELETE /entities/:id
    bulkCreate: boolean;       // POST /entities/bulk
    bulkUpdate: boolean;       // PUT /entities/bulk
    bulkDelete: boolean;       // DELETE /entities/bulk
    search: boolean;           // GET /entities/search
    count: boolean;            // GET /entities/count
  };
  
  queryFeatures: {
    pagination: boolean;       // 分页支持
    sorting: boolean;          // 排序支持
    filtering: boolean;        // 过滤支持
    searching: boolean;        // 搜索支持
    relations: boolean;        // 关联数据
  };
  
  responseFormat: {
    wrapper: boolean;          // 响应包装
    metadata: boolean;         // 元数据信息
    timestamps: boolean;       // 时间戳
  };
}
```

### 控制器代码生成示例
```typescript
// 自动生成的Controller
@Controller('users')
@ApiTags('用户管理')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  @ApiOperation({ summary: '创建用户' })
  async create(@Body() createUserDto: CreateUserDto) {
    return this.userService.create(createUserDto);
  }

  @Get()
  @ApiOperation({ summary: '获取用户列表' })
  async findAll(@Query() query: FindAllUsersDto) {
    return this.userService.findAll(query);
  }

  @Get(':id')
  @ApiOperation({ summary: '获取用户详情' })
  async findOne(@Param('id') id: string) {
    return this.userService.findOne(id);
  }
}
```

## 🔍 查询构建器

### 可视化查询设计
```typescript
interface QueryDefinition {
  id: string;
  name: string;
  description?: string;
  
  // 主表配置
  baseEntity: {
    entityId: string;
    alias: string;
  };
  
  // 连接配置
  joins: JoinDefinition[];
  
  // 字段选择
  select: SelectField[];
  
  // 条件配置
  where: WhereCondition[];
  
  // 排序配置
  orderBy: OrderByField[];
  
  // 分组配置
  groupBy: GroupByField[];
  having: HavingCondition[];
  
  // 分页配置
  pagination: {
    enabled: boolean;
    defaultSize: number;
    maxSize: number;
  };
}

interface WhereCondition {
  logic: 'AND' | 'OR';
  field: string;
  operator: ComparisonOperator;  // equals, gt, lt, like, in, between等
  value: any;
  dataType: FieldType;
}
```

### SQL生成引擎
```typescript
@Injectable()
export class QueryBuilderService {
  async executeQuery(queryDef: QueryDefinition, params: any = {}) {
    // 构建SQL查询
    const sql = this.buildSQLFromDefinition(queryDef, params);
    
    // 执行查询
    const result = await this.prismaService.$queryRaw(sql);
    
    return this.processQueryResult(result, queryDef);
  }

  private buildSQLFromDefinition(queryDef: QueryDefinition, params: any): string {
    const { baseEntity, joins, select, where, orderBy } = queryDef;
    
    // 构建SELECT、FROM、JOIN、WHERE、ORDER BY子句
    const selectClause = this.buildSelectClause(select);
    const fromClause = `FROM ${baseEntity.entityId} AS ${baseEntity.alias}`;
    const joinClause = joins.map(join => this.buildJoinClause(join)).join(' ');
    const whereClause = where.length > 0 ? 
      `WHERE ${this.buildWhereClause(where, params)}` : '';
    const orderByClause = orderBy.length > 0 ? 
      `ORDER BY ${orderBy.map(o => `${o.entityAlias}.${o.fieldCode} ${o.direction}`).join(', ')}` : '';
    
    return [selectClause, fromClause, joinClause, whereClause, orderByClause]
      .filter(Boolean).join(' ');
  }
}
```

## 🛠️ 代码生成引擎

### 模板系统
```typescript
interface CodeTemplate {
  id: string;
  name: string;
  code: string;
  type: TemplateType;          // entity, dto, service, controller等
  category: TemplateCategory;
  
  // 技术配置
  language: 'typescript' | 'javascript';
  framework: 'nestjs' | 'express';
  
  // 模板内容(Handlebars格式)
  content: string;
  
  // 变量定义
  variables: TemplateVariable[];
  
  // 输出配置
  output: {
    filename: string;          // 输出文件名模板
    directory: string;         // 输出目录模板
    extension: string;         // 文件扩展名
  };
  
  dependencies: string[];      // 依赖的其他模板
  version: string;
}

enum TemplateType {
  ENTITY = 'entity',
  DTO = 'dto',
  SERVICE = 'service',
  CONTROLLER = 'controller',
  MODULE = 'module',
  TEST = 'test',
  CONFIG = 'config'
}
```

### 代码生成流程
```typescript
@Injectable()
export class CodeGenerationService {
  async generateProject(projectId: string, options: GenerationOptions): Promise<GenerationResult> {
    // 创建生成任务
    const task = await this.createGenerationTask(projectId, options);
    
    try {
      // 获取项目元数据
      const metadata = await this.getProjectMetadata(projectId);
      
      // 生成代码文件
      const files = await this.generateCodeFiles(metadata, options);
      
      // 验证生成的代码
      const validation = await this.validateGeneratedCode(files);
      
      // 保存到文件系统
      const output = await this.saveGeneratedFiles(files, options.outputPath);
      
      return { taskId: task.id, files, output, validation };
      
    } catch (error) {
      await this.updateTaskStatus(task.id, 'FAILED', { error: error.message });
      throw error;
    }
  }

  private async generateCodeFiles(metadata: ProjectMetadata, options: GenerationOptions): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    
    // 为每个实体生成代码文件
    for (const entity of metadata.entities) {
      files.push(...await this.generateEntityFiles(entity, options));
    }
    
    // 生成模块文件
    files.push(await this.generateAppModule(metadata, options));
    
    // 生成配置文件
    files.push(...await this.generateConfigFiles(metadata, options));
    
    return files;
  }
}
```

## 🚀 部署与运行时

### 动态部署引擎
```typescript
@Injectable()
export class DeploymentService {
  async deployProject(projectId: string): Promise<DeploymentResult> {
    try {
      // 1. 生成代码
      await this.generateProjectCode(projectId);
      
      // 2. 安装依赖
      await this.installDependencies(projectId);
      
      // 3. 构建项目
      await this.buildProject(projectId);
      
      // 4. 启动服务
      const port = await this.startService(projectId);
      
      // 5. 更新部署状态
      await this.updateDeploymentStatus(projectId, 'DEPLOYED', port);
      
      return {
        status: 'success',
        port,
        url: `http://localhost:${port}`
      };
      
    } catch (error) {
      await this.updateDeploymentStatus(projectId, 'FAILED');
      throw error;
    }
  }

  private async startService(projectId: string): Promise<number> {
    const port = await this.findAvailablePort();
    
    // 启动Node.js进程
    const child = spawn('npm', ['run', 'start:prod'], {
      cwd: this.getProjectPath(projectId),
      env: { ...process.env, PORT: port.toString() },
      detached: true,
      stdio: 'pipe'
    });
    
    // 存储进程信息
    this.activeProcesses.set(projectId, {
      pid: child.pid,
      port,
      startTime: Date.now()
    });
    
    return port;
  }
}
```

### 运行时管理
```typescript
@Injectable()
export class RuntimeService {
  private activeProcesses = new Map<string, ProcessInfo>();

  async getProjectStatus(projectId: string): Promise<ProjectStatus> {
    const process = this.activeProcesses.get(projectId);
    
    if (!process) {
      return { status: 'stopped' };
    }
    
    // 检查进程是否还在运行
    const isRunning = await this.checkProcessHealth(process);
    
    return {
      status: isRunning ? 'running' : 'stopped',
      port: process.port,
      uptime: Date.now() - process.startTime,
      pid: process.pid
    };
  }

  async stopProject(projectId: string): Promise<void> {
    const process = this.activeProcesses.get(projectId);
    
    if (process) {
      // 优雅关闭进程
      process.kill('SIGTERM');
      
      // 等待进程关闭
      await this.waitForProcessExit(process.pid);
      
      this.activeProcesses.delete(projectId);
    }
  }
}
```

## 📊 平台特色功能

### 实时代码预览
- **即时生成**: 配置变更实时生成代码预览
- **语法高亮**: 支持TypeScript语法高亮显示
- **文件树**: 显示完整的项目文件结构
- **差异对比**: 配置变更前后的代码差异

### 智能验证系统
- **语法验证**: 自动检查生成代码的语法正确性
- **依赖检查**: 验证模块间依赖关系
- **规范检查**: 代码风格和命名规范检查
- **性能分析**: 生成代码的性能评估

### 版本管理
- **模板版本**: 支持模板的版本管理和回滚
- **项目版本**: 项目配置的版本控制
- **代码版本**: 生成代码的版本追踪
- **变更日志**: 详细的变更历史记录

### 扩展机制
- **自定义模板**: 支持用户自定义代码模板
- **插件系统**: 支持功能插件扩展
- **钩子函数**: 代码生成过程的钩子函数
- **API开放**: 提供完整的平台API接口

这个低代码平台通过可视化建模、智能代码生成和自动化部署，大大提升了后端开发的效率和质量，是现代企业级应用开发的有力工具。