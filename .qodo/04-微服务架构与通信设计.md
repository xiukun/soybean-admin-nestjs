# SoybeanAdmin NestJS å¾®æœåŠ¡æ¶æ„ä¸é€šä¿¡è®¾è®¡

## ğŸ—ï¸ å¾®æœåŠ¡æ¶æ„æ¦‚è§ˆ

### æœåŠ¡æ‹†åˆ†ç­–ç•¥

SoybeanAdmin NestJS é‡‡ç”¨**ä¸šåŠ¡åŸŸé©±åŠ¨çš„å¾®æœåŠ¡æ‹†åˆ†**ï¼Œæ¯ä¸ªæœåŠ¡è´Ÿè´£ç‰¹å®šçš„ä¸šåŠ¡é¢†åŸŸï¼š

```mermaid
graph TB
    subgraph "å‰ç«¯å±‚"
        A[ç®¡ç†å‰ç«¯<br/>Vue3 + Vite5<br/>:9527]
        B[ä½ä»£ç è®¾è®¡å™¨<br/>Vue3 + X6<br/>:9555]
    end
    
    subgraph "ç½‘å…³å±‚"
        C[Nginxåå‘ä»£ç†<br/>è´Ÿè½½å‡è¡¡ + é™æ€èµ„æº]
    end
    
    subgraph "åº”ç”¨æœåŠ¡å±‚"
        D[ä¸»ä¸šåŠ¡æœåŠ¡<br/>backend<br/>:9528]
        E[ä½ä»£ç å¹³å°æœåŠ¡<br/>lowcode-platform<br/>:3002]
        F[åŠ¨æ€ä¸šåŠ¡è¿è¡Œæ—¶<br/>amis-backend<br/>:9522]
    end
    
    subgraph "æ•°æ®å±‚"
        G[(PostgreSQL<br/>å¤šSchemaè®¾è®¡<br/>:25432)]
        H[(Redisé›†ç¾¤<br/>ç¼“å­˜ä¸ä¼šè¯<br/>:26379)]
    end
    
    A --> C
    B --> C
    C --> D
    C --> E
    C --> F
    
    D --> G
    E --> G
    F --> G
    
    D --> H
    E --> H
    F --> H
```

### æœåŠ¡èŒè´£åˆ’åˆ†

| æœåŠ¡åç§° | ç«¯å£ | æ ¸å¿ƒèŒè´£ | ä¸šåŠ¡è¾¹ç•Œ |
|---------|------|----------|----------|
| **backend** | 9528 | ä¼ä¸šç®¡ç†ç³»ç»Ÿæ ¸å¿ƒä¸šåŠ¡ | ç”¨æˆ·ç®¡ç†ã€æƒé™æ§åˆ¶ã€å¤šç§Ÿæˆ·ã€å®¡è®¡æ—¥å¿— |
| **lowcode-platform** | 3002 | ä½ä»£ç å¹³å°æ ¸å¿ƒå¼•æ“ | é¡¹ç›®ç®¡ç†ã€å®ä½“å»ºæ¨¡ã€ä»£ç ç”Ÿæˆã€æ¨¡æ¿ç®¡ç† |
| **amis-backend** | 9522 | åŠ¨æ€ä¸šåŠ¡ä»£ç è¿è¡Œæ—¶ | ç”Ÿæˆä»£ç æ‰§è¡Œã€åŠ¨æ€APIã€ä¸šåŠ¡æ•°æ®å¤„ç† |

## ğŸ”„ æœåŠ¡é—´é€šä¿¡æ¶æ„

### é€šä¿¡æ¨¡å¼é€‰æ‹©

#### 1. åŒæ­¥é€šä¿¡ - HTTP REST API
**é€‚ç”¨åœºæ™¯**: ä¸»è¦çš„æœåŠ¡é—´è°ƒç”¨ï¼Œéœ€è¦å³æ—¶å“åº”
```typescript
// æœåŠ¡é—´HTTPé€šä¿¡ç¤ºä¾‹
@Injectable()
export class ServiceCommunicationService {
  constructor(private readonly httpService: HttpService) {}

  async callLowcodePlatform(endpoint: string, data?: any) {
    const baseUrl = this.configService.get('LOWCODE_PLATFORM_URL');
    return this.httpService.post(`${baseUrl}${endpoint}`, data).toPromise();
  }

  async callAmisBackend(endpoint: string, data?: any) {
    const baseUrl = this.configService.get('AMIS_BACKEND_URL');
    return this.httpService.post(`${baseUrl}${endpoint}`, data).toPromise();
  }
}
```

#### 2. å¼‚æ­¥é€šä¿¡ - äº‹ä»¶é©±åŠ¨æ¶æ„
**é€‚ç”¨åœºæ™¯**: çŠ¶æ€å˜æ›´é€šçŸ¥ï¼Œä¸éœ€è¦å³æ—¶å“åº”
```typescript
// äº‹ä»¶å‘å¸ƒè®¢é˜…ç¤ºä¾‹
@Injectable()
export class ProjectEventService {
  constructor(private eventEmitter: EventEmitter2) {}

  // å‘å¸ƒé¡¹ç›®éƒ¨ç½²äº‹ä»¶
  publishProjectDeployed(projectId: string, port: number) {
    this.eventEmitter.emit('project.deployed', {
      projectId,
      port,
      timestamp: new Date()
    });
  }

  // è®¢é˜…é¡¹ç›®éƒ¨ç½²äº‹ä»¶
  @OnEvent('project.deployed')
  handleProjectDeployed(payload: any) {
    // æ›´æ–°éƒ¨ç½²çŠ¶æ€ï¼Œé€šçŸ¥ç›¸å…³æœåŠ¡
  }
}
```

### APIç½‘å…³è·¯ç”±è®¾è®¡

```nginx
# Nginx è·¯ç”±é…ç½®
upstream backend_service {
    server backend:9528;
}

upstream lowcode_platform_service {
    server lowcode-platform:3002;
}

upstream amis_backend_service {
    server amis-backend:9522;
}

server {
    listen 80;
    
    # ä¸»ä¸šåŠ¡APIè·¯ç”±
    location /api/v1/ {
        proxy_pass http://backend_service;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # ä½ä»£ç å¹³å°APIè·¯ç”±
    location /lowcode/api/v1/ {
        rewrite ^/lowcode/api/v1/(.*) /api/v1/$1 break;
        proxy_pass http://lowcode_platform_service;
    }
    
    # åŠ¨æ€ä¸šåŠ¡APIè·¯ç”±
    location /amis/api/v1/ {
        rewrite ^/amis/api/v1/(.*) /api/v1/$1 break;
        proxy_pass http://amis_backend_service;
    }
    
    # å‰ç«¯é™æ€èµ„æº
    location / {
        proxy_pass http://frontend:80;
    }
}
```

## ğŸ” æœåŠ¡è®¤è¯ä¸æˆæƒ

### ç»Ÿä¸€JWTè®¤è¯ç­–ç•¥

#### JWTä»¤ç‰Œè®¾è®¡
```typescript
interface JWTPayload {
  sub: string;          // ç”¨æˆ·ID
  username: string;     // ç”¨æˆ·å
  domain: string;       // åŸŸ
  tenantId?: string;    // ç§Ÿæˆ·ID
  roles: string[];      // è§’è‰²åˆ—è¡¨
  permissions: string[]; // æƒé™åˆ—è¡¨
  iat: number;          // ç­¾å‘æ—¶é—´
  exp: number;          // è¿‡æœŸæ—¶é—´
}
```

#### æœåŠ¡é—´è®¤è¯ä¸­é—´ä»¶
```typescript
@Injectable()
export class ServiceAuthMiddleware implements NestMiddleware {
  constructor(
    private jwtService: JwtService,
    private configService: ConfigService
  ) {}

  use(req: Request, res: Response, next: NextFunction) {
    const token = this.extractTokenFromHeader(req);
    
    if (token) {
      try {
        const payload = this.jwtService.verify(token, {
          secret: this.configService.get('JWT_SECRET')
        });
        
        // è®¾ç½®ç”¨æˆ·ä¸Šä¸‹æ–‡
        req['user'] = payload;
        req['tenantId'] = payload.tenantId;
        
      } catch (error) {
        throw new UnauthorizedException('Invalid token');
      }
    }
    
    next();
  }
}
```

### æƒé™æ§åˆ¶ç­–ç•¥

#### Casbinæƒé™æ¨¡å‹ç»Ÿä¸€
```conf
# RBACæƒé™æ¨¡å‹ (model.conf)
[request_definition]
r = sub, obj, act, domain

[policy_definition]
p = sub, obj, act, domain

[role_definition]
g = _, _, _
g2 = _, _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub, r.domain) && r.obj == p.obj && r.act == p.act && r.domain == p.domain
```

#### è·¨æœåŠ¡æƒé™éªŒè¯
```typescript
@Injectable()
export class CrossServiceAuthGuard implements CanActivate {
  constructor(
    private enforcer: Enforcer,
    private reflector: Reflector
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    
    if (!user) return false;
    
    // è·å–æƒé™è¦æ±‚
    const requiredPermission = this.reflector.get<string>(
      'permission',
      context.getHandler()
    );
    
    if (!requiredPermission) return true;
    
    // éªŒè¯æƒé™
    return this.enforcer.enforce(
      user.sub,
      requiredPermission,
      'read',
      user.domain
    );
  }
}
```

## ğŸ“Š æ•°æ®ä¸€è‡´æ€§ä¿éšœ

### åˆ†å¸ƒå¼äº‹åŠ¡å¤„ç†

#### Sagaæ¨¡å¼å®ç°
```typescript
@Injectable()
export class ProjectDeploymentSaga {
  constructor(
    private codeGenerationService: CodeGenerationService,
    private deploymentService: DeploymentService,
    private eventBus: EventBus
  ) {}

  @Saga()
  async handleProjectDeployment(command: DeployProjectCommand) {
    return [
      // æ­¥éª¤1: ç”Ÿæˆä»£ç 
      new GenerateCodeCommand(command.projectId),
      // æ­¥éª¤2: æ„å»ºé¡¹ç›®
      new BuildProjectCommand(command.projectId),
      // æ­¥éª¤3: éƒ¨ç½²æœåŠ¡
      new DeployServiceCommand(command.projectId),
      // æ­¥éª¤4: æ›´æ–°çŠ¶æ€
      new UpdateDeploymentStatusCommand(command.projectId, 'DEPLOYED')
    ];
  }

  @SagaOrchestrationStart()
  async generateCode(command: GenerateCodeCommand) {
    try {
      await this.codeGenerationService.generateProject(command.projectId);
      return new GenerateCodeSucceededEvent(command.projectId);
    } catch (error) {
      return new GenerateCodeFailedEvent(command.projectId, error.message);
    }
  }
}
```

### æ•°æ®åŒæ­¥ç­–ç•¥

#### æœ€ç»ˆä¸€è‡´æ€§å®ç°
```typescript
@Injectable()
export class DataSyncService {
  constructor(
    private eventEmitter: EventEmitter2,
    private schedulerRegistry: SchedulerRegistry
  ) {}

  // å®šæ—¶æ•°æ®åŒæ­¥
  @Cron('0 */5 * * * *') // æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
  async syncProjectData() {
    const projects = await this.getModifiedProjects();
    
    for (const project of projects) {
      await this.syncProjectToAmisBackend(project);
    }
  }

  // å®æ—¶æ•°æ®åŒæ­¥
  @OnEvent('project.updated')
  async handleProjectUpdated(event: ProjectUpdatedEvent) {
    // å¼‚æ­¥åŒæ­¥åˆ°Amisåç«¯
    await this.syncProjectToAmisBackend(event.project);
    
    // é€šçŸ¥å…¶ä»–æœåŠ¡
    this.eventEmitter.emit('project.synced', {
      projectId: event.project.id,
      timestamp: new Date()
    });
  }
}
```

## ğŸš€ æœåŠ¡å‘ç°ä¸è´Ÿè½½å‡è¡¡

### å¥åº·æ£€æŸ¥æœºåˆ¶

#### ç»Ÿä¸€å¥åº·æ£€æŸ¥æ¥å£
```typescript
@Controller('health')
export class HealthController {
  constructor(
    private prismaService: PrismaService,
    private redisService: RedisService,
    private httpService: HttpService
  ) {}

  @Get()
  async getHealth() {
    const checks = await Promise.allSettled([
      this.checkDatabase(),
      this.checkRedis(),
      this.checkDependentServices()
    ]);

    return {
      status: checks.every(check => check.status === 'fulfilled') ? 'healthy' : 'unhealthy',
      timestamp: new Date(),
      checks: {
        database: this.getCheckResult(checks[0]),
        redis: this.getCheckResult(checks[1]),
        services: this.getCheckResult(checks[2])
      }
    };
  }

  @Get('ready')
  async getReadiness() {
    // æ£€æŸ¥æœåŠ¡æ˜¯å¦å‡†å¤‡å¥½æ¥å—æµé‡
    return {
      status: 'ready',
      timestamp: new Date()
    };
  }

  @Get('live')
  async getLiveness() {
    // æ£€æŸ¥æœåŠ¡æ˜¯å¦å­˜æ´»
    return {
      status: 'alive',
      timestamp: new Date()
    };
  }
}
```

### Dockerå®¹å™¨ç¼–æ’

#### æœåŠ¡ä¾èµ–ç®¡ç†
```yaml
# docker-compose.yml æœåŠ¡ä¾èµ–é…ç½®
version: '3.8'

services:
  # æ•°æ®åº“æœåŠ¡ (æœ€åº•å±‚ä¾èµ–)
  postgres:
    image: postgres:16.3
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U soybean"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis/redis-stack:7.2.0
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ä¸»ä¸šåŠ¡æœåŠ¡
  backend:
    build: ./backend
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9528/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # ä½ä»£ç å¹³å°æœåŠ¡
  lowcode-platform:
    build: ./lowcode-platform-backend
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      backend:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "http://localhost:3002/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # åŠ¨æ€ä¸šåŠ¡è¿è¡Œæ—¶
  amis-backend:
    build: ./amis-lowcode-backend
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9522/api/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ç¼“å­˜ç­–ç•¥è®¾è®¡

#### å¤šçº§ç¼“å­˜æ¶æ„
```typescript
@Injectable()
export class CacheManagerService {
  constructor(
    private redisService: RedisService,
    private cacheManager: Cache
  ) {}

  // L1ç¼“å­˜: å†…å­˜ç¼“å­˜ (è¿›ç¨‹çº§)
  async getFromL1Cache(key: string) {
    return this.cacheManager.get(key);
  }

  // L2ç¼“å­˜: Redisç¼“å­˜ (æœåŠ¡çº§)
  async getFromL2Cache(key: string) {
    return this.redisService.get(key);
  }

  // å¤šçº§ç¼“å­˜è·å–ç­–ç•¥
  async getCachedData(key: string, fetchFunction: () => Promise<any>) {
    // å°è¯•ä»L1ç¼“å­˜è·å–
    let data = await this.getFromL1Cache(key);
    if (data) return data;

    // å°è¯•ä»L2ç¼“å­˜è·å–
    data = await this.getFromL2Cache(key);
    if (data) {
      // å›å¡«L1ç¼“å­˜
      await this.cacheManager.set(key, data, 300); // 5åˆ†é’Ÿ
      return data;
    }

    // ä»æ•°æ®æºè·å–
    data = await fetchFunction();
    
    // åŒæ—¶æ›´æ–°L1å’ŒL2ç¼“å­˜
    await Promise.all([
      this.cacheManager.set(key, data, 300),
      this.redisService.setex(key, 1800, JSON.stringify(data)) // 30åˆ†é’Ÿ
    ]);

    return data;
  }
}
```

### è¿æ¥æ± ä¼˜åŒ–

#### æ•°æ®åº“è¿æ¥æ± é…ç½®
```typescript
// Prismaè¿æ¥æ± é…ç½®
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  
  // è¿æ¥æ± é…ç½®
  directUrl = env("DIRECT_DATABASE_URL")
  
  // è¿æ¥æ± å‚æ•°
  pool_size = 20          // è¿æ¥æ± å¤§å°
  connection_limit = 100  // æœ€å¤§è¿æ¥æ•°
  pool_timeout = 10       // è¿æ¥è¶…æ—¶
}

// Redisè¿æ¥æ± é…ç½®
@Module({
  imports: [
    CacheModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        store: redisStore,
        host: configService.get('REDIS_HOST'),
        port: configService.get('REDIS_PORT'),
        password: configService.get('REDIS_PASSWORD'),
        db: configService.get('REDIS_DB'),
        // è¿æ¥æ± é…ç½®
        maxRetriesPerRequest: 3,
        retryDelayOnFailover: 100,
        enableReadyCheck: true,
        lazyConnect: true,
        // è¿æ¥æ± å¤§å°
        family: 4,
        connectTimeout: 60000,
        commandTimeout: 5000
      }),
      inject: [ConfigService]
    })
  ]
})
export class CacheManagerModule {}
```

## ğŸ” ç›‘æ§ä¸æ—¥å¿—

### åˆ†å¸ƒå¼é“¾è·¯è¿½è¸ª

#### è¯·æ±‚IDä¼ æ’­
```typescript
@Injectable()
export class RequestContextMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // ç”Ÿæˆæˆ–è·å–è¯·æ±‚ID
    const requestId = req.headers['x-request-id'] as string || 
                     this.generateRequestId();
    
    // è®¾ç½®è¯·æ±‚ä¸Šä¸‹æ–‡
    req['requestId'] = requestId;
    res.setHeader('x-request-id', requestId);
    
    // ä¼ æ’­åˆ°ä¸‹æ¸¸æœåŠ¡
    this.propagateRequestContext(req);
    
    next();
  }

  private propagateRequestContext(req: Request) {
    // åœ¨HTTPå®¢æˆ·ç«¯è¯·æ±‚ä¸­è‡ªåŠ¨æ·»åŠ è¿½è¸ªå¤´
    this.httpService.axiosRef.interceptors.request.use(config => {
      config.headers['x-request-id'] = req['requestId'];
      config.headers['x-service-name'] = process.env.SERVICE_NAME;
      return config;
    });
  }
}
```

### æœåŠ¡ç›‘æ§æŒ‡æ ‡

#### PrometheusæŒ‡æ ‡æ”¶é›†
```typescript
@Injectable()
export class MetricsService {
  private httpRequestDuration = new prometheus.Histogram({
    name: 'http_request_duration_seconds',
    help: 'Duration of HTTP requests in seconds',
    labelNames: ['method', 'route', 'status']
  });

  private httpRequestTotal = new prometheus.Counter({
    name: 'http_requests_total',
    help: 'Total number of HTTP requests',
    labelNames: ['method', 'route', 'status']
  });

  recordRequest(method: string, route: string, status: number, duration: number) {
    this.httpRequestTotal.inc({ method, route, status: status.toString() });
    this.httpRequestDuration.observe({ method, route, status: status.toString() }, duration);
  }

  @Get('metrics')
  getMetrics() {
    return prometheus.register.metrics();
  }
}
```

## ğŸ›¡ï¸ å®¹é”™ä¸é™çº§

### ç†”æ–­å™¨æ¨¡å¼

```typescript
@Injectable()
export class CircuitBreakerService {
  private circuits = new Map<string, CircuitBreaker>();

  getCircuitBreaker(serviceName: string) {
    if (!this.circuits.has(serviceName)) {
      const breaker = new CircuitBreaker(this.callService.bind(this, serviceName), {
        timeout: 5000,           // 5ç§’è¶…æ—¶
        errorThresholdPercentage: 50,  // 50%é”™è¯¯ç‡
        resetTimeout: 30000,     // 30ç§’åå°è¯•æ¢å¤
        rollingCountTimeout: 10000,    // 10ç§’ç»Ÿè®¡çª—å£
        rollingCountBuckets: 10  // ç»Ÿè®¡æ¡¶æ•°é‡
      });

      breaker.fallback(() => this.getFallbackResponse(serviceName));
      this.circuits.set(serviceName, breaker);
    }

    return this.circuits.get(serviceName);
  }

  private getFallbackResponse(serviceName: string) {
    switch (serviceName) {
      case 'lowcode-platform':
        return { status: 'degraded', message: 'ä½ä»£ç å¹³å°æš‚ä¸å¯ç”¨' };
      case 'amis-backend':
        return { status: 'degraded', message: 'ä¸šåŠ¡æœåŠ¡æš‚ä¸å¯ç”¨' };
      default:
        return { status: 'error', message: 'æœåŠ¡ä¸å¯ç”¨' };
    }
  }
}
```

### ä¼˜é›…é™çº§ç­–ç•¥

```typescript
@Injectable()
export class DegradationService {
  constructor(
    private circuitBreakerService: CircuitBreakerService,
    private cacheService: CacheService
  ) {}

  async callWithDegradation<T>(
    serviceName: string,
    operation: () => Promise<T>,
    fallbackKey?: string
  ): Promise<T> {
    const breaker = this.circuitBreakerService.getCircuitBreaker(serviceName);

    try {
      return await breaker.fire();
    } catch (error) {
      // å°è¯•ä»ç¼“å­˜è·å–
      if (fallbackKey) {
        const cached = await this.cacheService.get(fallbackKey);
        if (cached) {
          return cached as T;
        }
      }

      // è¿”å›é™çº§å“åº”
      throw new ServiceUnavailableException(`${serviceName} is currently unavailable`);
    }
  }
}
```

## ğŸ“‹ æ€»ç»“

SoybeanAdmin NestJSçš„å¾®æœåŠ¡æ¶æ„å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### æ¶æ„ä¼˜åŠ¿
1. **æ¸…æ™°çš„æœåŠ¡è¾¹ç•Œ**: æŒ‰ä¸šåŠ¡åŸŸåˆ’åˆ†æœåŠ¡ï¼ŒèŒè´£æ˜ç¡®
2. **ç»Ÿä¸€çš„è®¤è¯æˆæƒ**: JWT + Casbin çš„ç»Ÿä¸€æƒé™æ¨¡å‹
3. **å®Œå–„çš„å®¹é”™æœºåˆ¶**: ç†”æ–­å™¨ + é™çº§ç­–ç•¥
4. **é«˜å¯ç”¨è®¾è®¡**: å¥åº·æ£€æŸ¥ + è‡ªåŠ¨æ¢å¤

### é€šä¿¡ç‰¹ç‚¹
1. **å¤šç§é€šä¿¡æ¨¡å¼**: åŒæ­¥HTTP + å¼‚æ­¥äº‹ä»¶
2. **ç»Ÿä¸€çš„é“¾è·¯è¿½è¸ª**: åˆ†å¸ƒå¼è¯·æ±‚è¿½è¸ª
3. **å®Œå–„çš„ç›‘æ§ä½“ç³»**: æŒ‡æ ‡æ”¶é›† + æ—¥å¿—èšåˆ

### æ‰©å±•æ€§è®¾è®¡
1. **æ°´å¹³æ‰©å±•**: æ— çŠ¶æ€æœåŠ¡è®¾è®¡
2. **æœåŠ¡å‘ç°**: åŸºäºå®¹å™¨ç¼–æ’çš„æœåŠ¡å‘ç°
3. **é…ç½®å¤–éƒ¨åŒ–**: ç¯å¢ƒå˜é‡ + é…ç½®ä¸­å¿ƒ

è¿™ä¸ªå¾®æœåŠ¡æ¶æ„ä¸ºæ•´ä¸ªä½ä»£ç å¹³å°æä¾›äº†ç¨³å®šã€å¯æ‰©å±•ã€é«˜æ€§èƒ½çš„æŠ€æœ¯åŸºç¡€ã€‚