# 低代码平台技术实现规范

## 📋 技术架构规范

### 代码生成器架构设计

```typescript
// 代码生成器核心架构
lowcode-platform-backend/src/
├── lib/bounded-contexts/code-generation/
│   ├── application/
│   │   ├── services/
│   │   │   ├── intelligent-code-generator.service.ts    # 核心生成服务
│   │   │   ├── amis-backend-manager.service.ts         # 目标服务管理
│   │   │   ├── template-engine.service.ts              # 模板引擎
│   │   │   └── file-system-manager.service.ts          # 文件系统管理
│   │   └── handlers/
│   │       └── generate-code.handler.ts                # 生成命令处理器
│   └── infrastructure/
│       ├── templates/                                  # 模板仓储
│       └── file-writers/                              # 文件写入器
└── resources/templates/                                # 模板文件
    ├── entity-controller.hbs                          # 控制器模板
    ├── entity-module.hbs                              # 模块模板
    ├── prisma-schema.hbs                              # Schema模板
    └── amis-page.hbs                                  # 页面模板
```

### 目标服务架构设计

```typescript
// amis-lowcode-backend 分层架构
amis-lowcode-backend/src/
├── base/                                              # 基础代码层 (自动生成)
│   ├── controllers/                                   # 基础控制器
│   │   └── {entity}.base.controller.ts
│   ├── services/                                      # 基础服务
│   │   └── {entity}.base.service.ts
│   ├── dto/                                          # 数据传输对象
│   │   └── {entity}.dto.ts
│   └── entities/                                     # 实体模型
│       └── {entity}.entity.ts
├── biz/                                              # 业务代码层 (可扩展)
│   ├── controllers/                                   # 业务控制器
│   │   └── {entity}.controller.ts
│   ├── services/                                      # 业务服务
│   │   └── {entity}.service.ts
│   └── modules/                                       # 业务模块
│       └── {entity}.module.ts
└── shared/                                           # 共享模块
    ├── interceptors/
    │   └── amis-response.interceptor.ts              # Amis响应拦截器
    ├── decorators/
    │   └── amis-api.decorator.ts                     # Amis API装饰器
    └── utils/
        └── amis-response.util.ts                     # Amis响应工具
```

## 🎯 核心功能实现规范

### 1. 代码模板规范

#### 1.1 控制器模板 (entity-controller.hbs)

```handlebars
import { Controller, Get, Post, Put, Delete, Body, Param, Query } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { {{pascalCase entity.code}}BaseController } from '../base/controllers/{{kebabCase entity.code}}.base.controller';
import { {{pascalCase entity.code}}Service } from '../services/{{kebabCase entity.code}}.service';
import { Create{{pascalCase entity.code}}Dto, Update{{pascalCase entity.code}}Dto } from '../dto/{{kebabCase entity.code}}.dto';
import { AmisResponse } from '../shared/decorators/amis-api.decorator';

@ApiTags('{{entity.name}}')
@Controller('{{kebabCase entity.code}}')
export class {{pascalCase entity.code}}Controller extends {{pascalCase entity.code}}BaseController {
  constructor(private readonly {{camelCase entity.code}}Service: {{pascalCase entity.code}}Service) {
    super({{camelCase entity.code}}Service);
  }

  @Get()
  @ApiOperation({ summary: '获取{{entity.name}}列表' })
  @AmisResponse()
  async findAll(@Query() query: any) {
    return super.findAll(query);
  }

  @Get(':id')
  @ApiOperation({ summary: '获取{{entity.name}}详情' })
  @AmisResponse()
  async findOne(@Param('id') id: string) {
    return super.findOne(id);
  }

  @Post()
  @ApiOperation({ summary: '创建{{entity.name}}' })
  @AmisResponse()
  async create(@Body() createDto: Create{{pascalCase entity.code}}Dto) {
    return super.create(createDto);
  }

  @Put(':id')
  @ApiOperation({ summary: '更新{{entity.name}}' })
  @AmisResponse()
  async update(@Param('id') id: string, @Body() updateDto: Update{{pascalCase entity.code}}Dto) {
    return super.update(id, updateDto);
  }

  @Delete(':id')
  @ApiOperation({ summary: '删除{{entity.name}}' })
  @AmisResponse()
  async remove(@Param('id') id: string) {
    return super.remove(id);
  }
}
```

#### 1.2 模块模板 (entity-module.hbs)

```handlebars
import { Module } from '@nestjs/common';
import { {{pascalCase entity.code}}Controller } from '../controllers/{{kebabCase entity.code}}.controller';
import { {{pascalCase entity.code}}Service } from '../services/{{kebabCase entity.code}}.service';
import { PrismaModule } from '../shared/prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [{{pascalCase entity.code}}Controller],
  providers: [{{pascalCase entity.code}}Service],
  exports: [{{pascalCase entity.code}}Service],
})
export class {{pascalCase entity.code}}Module {}
```

#### 1.3 Prisma Schema模板 (prisma-schema.hbs)

```handlebars
{{#each entities}}
model {{pascalCase code}} {
  {{#each fields}}
  {{camelCase code}} {{prismaType type}}{{#if nullable}}?{{/if}}{{#if primaryKey}} @id{{/if}}{{#if uniqueConstraint}} @unique{{/if}}{{#if defaultValue}} @default({{defaultValue}}){{/if}}{{#if comment}} // {{comment}}{{/if}}
  {{/each}}
  
  {{#each relationships}}
  {{#if (eq type 'ONE_TO_MANY')}}
  {{camelCase targetEntity.code}}s {{pascalCase targetEntity.code}}[]
  {{/if}}
  {{#if (eq type 'MANY_TO_ONE')}}
  {{camelCase targetEntity.code}} {{pascalCase targetEntity.code}} @relation(fields: [{{camelCase sourceField.code}}], references: [{{camelCase targetField.code}}])
  {{camelCase sourceField.code}} String
  {{/if}}
  {{#if (eq type 'MANY_TO_MANY')}}
  {{camelCase targetEntity.code}}s {{pascalCase targetEntity.code}}[]
  {{/if}}
  {{/each}}

  @@map("{{tableName}}")
}

{{/each}}
```

### 2. Amis兼容性实现规范

#### 2.1 响应拦截器实现

```typescript
// shared/interceptors/amis-response.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface AmisResponse<T> {
  status: 0 | 1;
  msg: string;
  data: T;
  count?: number;
}

@Injectable()
export class AmisResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<AmisResponse<any>> {
    return next.handle().pipe(
      map(data => {
        // 处理分页数据
        if (data && typeof data === 'object' && 'items' in data && 'total' in data) {
          return {
            status: 0,
            msg: 'success',
            data: {
              items: data.items,
              total: data.total
            },
            count: data.total
          };
        }

        // 处理普通数据
        return {
          status: 0,
          msg: 'success',
          data: data
        };
      })
    );
  }
}
```

#### 2.2 Amis API装饰器

```typescript
// shared/decorators/amis-api.decorator.ts
import { applyDecorators, UseInterceptors } from '@nestjs/common';
import { AmisResponseInterceptor } from '../interceptors/amis-response.interceptor';

export function AmisResponse() {
  return applyDecorators(
    UseInterceptors(AmisResponseInterceptor)
  );
}
```

### 3. 文件生成服务实现规范

#### 3.1 AmisBackendManagerService实现

```typescript
// application/services/amis-backend-manager.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs-extra';
import * as path from 'path';

export interface GeneratedFile {
  path: string;
  content: string;
  type: 'base' | 'biz';
  overwrite: boolean;
}

@Injectable()
export class AmisBackendManagerService {
  private readonly logger = new Logger(AmisBackendManagerService.name);
  private readonly amisBackendPath: string;

  constructor(private configService: ConfigService) {
    this.amisBackendPath = this.configService.get<string>('AMIS_BACKEND_PATH') || 
      path.join(process.cwd(), '../amis-lowcode-backend');
  }

  async writeGeneratedFiles(files: GeneratedFile[]): Promise<void> {
    this.logger.log(`Writing ${files.length} generated files...`);

    for (const file of files) {
      const fullPath = path.join(this.amisBackendPath, 'src', file.path);
      
      // 确保目录存在
      await fs.ensureDir(path.dirname(fullPath));
      
      // 检查文件是否存在且不允许覆盖
      if (!file.overwrite && await fs.pathExists(fullPath)) {
        this.logger.warn(`File exists and overwrite disabled: ${file.path}`);
        continue;
      }

      // 写入文件
      await fs.writeFile(fullPath, file.content, 'utf8');
      this.logger.log(`Generated file: ${file.path}`);
    }
  }

  async generatePrismaSchema(metadata: ProjectMetadata): Promise<void> {
    this.logger.log('Generating Prisma schema...');
    
    const schemaPath = path.join(this.amisBackendPath, 'prisma/schema.prisma');
    const templatePath = path.join(process.cwd(), 'src/resources/templates/prisma-schema.hbs');
    
    // 使用模板引擎生成schema
    const template = await fs.readFile(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(template);
    const schemaContent = compiledTemplate(metadata);
    
    // 写入schema文件
    await fs.writeFile(schemaPath, schemaContent, 'utf8');
    
    // 执行prisma generate
    await this.executePrismaGenerate();
  }

  async updateAppModule(entities: Entity[]): Promise<void> {
    this.logger.log('Updating app.module.ts...');
    
    const appModulePath = path.join(this.amisBackendPath, 'src/app.module.ts');
    
    // 生成模块导入代码
    const imports = entities.map(entity => 
      `import { ${entity.code}Module } from './biz/modules/${entity.code.toLowerCase()}.module';`
    ).join('\n');
    
    const modules = entities.map(entity => `${entity.code}Module`).join(',\n    ');
    
    const appModuleContent = `
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from './shared/prisma/prisma.module';
${imports}

@Module({
  imports: [
    ConfigModule.forRoot(),
    PrismaModule,
    ${modules}
  ],
})
export class AppModule {}
`;

    await fs.writeFile(appModulePath, appModuleContent, 'utf8');
  }

  async restartAmisBackend(): Promise<void> {
    this.logger.log('Restarting amis-lowcode-backend service...');
    
    // 实现服务重启逻辑
    // 可以通过PM2、Docker或其他方式重启服务
    try {
      const { exec } = require('child_process');
      await new Promise((resolve, reject) => {
        exec('cd ../amis-lowcode-backend && npm run start:dev', (error, stdout, stderr) => {
          if (error) {
            reject(error);
          } else {
            resolve(stdout);
          }
        });
      });
      
      this.logger.log('Service restarted successfully');
    } catch (error) {
      this.logger.error('Failed to restart service:', error);
      throw error;
    }
  }

  private async executePrismaGenerate(): Promise<void> {
    const { exec } = require('child_process');
    return new Promise((resolve, reject) => {
      exec('cd ../amis-lowcode-backend && npx prisma generate', (error, stdout, stderr) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }
}
```

### 4. 模板引擎服务实现规范

#### 4.1 TemplateEngineService实现

```typescript
// application/services/template-engine.service.ts
import { Injectable, Logger } from '@nestjs/common';
import * as Handlebars from 'handlebars';
import * as fs from 'fs-extra';
import * as path from 'path';

@Injectable()
export class TemplateEngineService {
  private readonly logger = new Logger(TemplateEngineService.name);
  private readonly templatesPath: string;

  constructor() {
    this.templatesPath = path.join(process.cwd(), 'src/resources/templates');
    this.registerHelpers();
  }

  async renderTemplate(templateName: string, data: any): Promise<string> {
    const templatePath = path.join(this.templatesPath, `${templateName}.hbs`);
    
    if (!await fs.pathExists(templatePath)) {
      throw new Error(`Template not found: ${templateName}`);
    }

    const templateContent = await fs.readFile(templatePath, 'utf8');
    const compiledTemplate = Handlebars.compile(templateContent);
    
    return compiledTemplate(data);
  }

  private registerHelpers(): void {
    // 注册Handlebars助手函数
    Handlebars.registerHelper('pascalCase', (str: string) => {
      return str.charAt(0).toUpperCase() + str.slice(1).replace(/_([a-z])/g, (g) => g[1].toUpperCase());
    });

    Handlebars.registerHelper('camelCase', (str: string) => {
      return str.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
    });

    Handlebars.registerHelper('kebabCase', (str: string) => {
      return str.replace(/_/g, '-').toLowerCase();
    });

    Handlebars.registerHelper('prismaType', (type: string) => {
      const typeMap = {
        'STRING': 'String',
        'INTEGER': 'Int',
        'FLOAT': 'Float',
        'BOOLEAN': 'Boolean',
        'DATE': 'DateTime',
        'TEXT': 'String',
        'JSON': 'Json'
      };
      return typeMap[type] || 'String';
    });

    Handlebars.registerHelper('eq', (a: any, b: any) => a === b);
  }
}
```

## 🔧 开发环境配置

### 环境变量配置

```bash
# .env
DATABASE_URL="postgresql://username:password@localhost:5432/lowcode_platform"
AMIS_BACKEND_PATH="../amis-lowcode-backend"
REDIS_URL="redis://localhost:6379"
JWT_SECRET="your-jwt-secret"
```

### 依赖包配置

```json
{
  "dependencies": {
    "handlebars": "^4.7.7",
    "fs-extra": "^11.1.1",
    "chokidar": "^3.5.3"
  },
  "devDependencies": {
    "@types/handlebars": "^4.1.0",
    "@types/fs-extra": "^11.0.1"
  }
}
```

## 📝 代码规范

### TypeScript规范
- 使用严格模式
- 所有函数必须有返回类型声明
- 使用接口定义数据结构
- 遵循ESLint规则

### 命名规范
- 类名使用PascalCase
- 方法名使用camelCase
- 常量使用UPPER_SNAKE_CASE
- 文件名使用kebab-case

### 注释规范
- 所有公共方法必须有JSDoc注释
- 复杂逻辑必须有行内注释
- 接口和类型必须有说明注释

---

*本文档版本: v1.0*  
*最后更新: 2025-07-21*
