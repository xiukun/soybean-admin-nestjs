# 低代码平台测试规范

## 📋 测试策略

### 测试金字塔
```
    E2E Tests (10%)
   ┌─────────────────┐
   │  用户界面测试     │
   │  业务流程测试     │
   └─────────────────┘
  
  Integration Tests (20%)
 ┌─────────────────────┐
 │   API接口测试        │
 │   服务集成测试       │
 │   数据库操作测试     │
 └─────────────────────┘

Unit Tests (70%)
┌─────────────────────────┐
│    业务逻辑测试          │
│    工具函数测试          │
│    模板引擎测试          │
│    数据验证测试          │
└─────────────────────────┘
```

### 测试覆盖率要求
- **单元测试**: ≥80%
- **集成测试**: ≥70%
- **E2E测试**: 核心流程100%
- **分支覆盖率**: ≥75%
- **函数覆盖率**: ≥85%

## 🧪 单元测试规范

### 1. 代码生成器测试

#### 1.1 模板引擎测试
```typescript
// template-engine.service.spec.ts
describe('TemplateEngineService', () => {
  let service: TemplateEngineService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [TemplateEngineService],
    }).compile();

    service = module.get<TemplateEngineService>(TemplateEngineService);
  });

  describe('renderTemplate', () => {
    it('should render entity controller template correctly', async () => {
      // Arrange
      const templateName = 'entity-controller';
      const mockEntity = {
        code: 'user',
        name: '用户',
        fields: [
          { code: 'username', name: '用户名', type: 'STRING' },
          { code: 'email', name: '邮箱', type: 'STRING' }
        ]
      };

      // Act
      const result = await service.renderTemplate(templateName, { entity: mockEntity });

      // Assert
      expect(result).toContain('@Controller(\'user\')');
      expect(result).toContain('export class UserController');
      expect(result).toContain('@Get()');
      expect(result).toContain('@Post()');
      expect(result).toContain('@Put(\':id\')');
      expect(result).toContain('@Delete(\':id\')');
    });

    it('should handle template variables correctly', async () => {
      const templateName = 'entity-model';
      const mockData = {
        entity: { code: 'test_entity', name: 'Test Entity' },
        fields: [
          { code: 'test_field', type: 'STRING', nullable: false }
        ]
      };

      const result = await service.renderTemplate(templateName, mockData);

      expect(result).toContain('TestEntity');
      expect(result).toContain('testField: string');
    });

    it('should throw error for non-existent template', async () => {
      await expect(service.renderTemplate('non-existent', {}))
        .rejects.toThrow('Template not found: non-existent');
    });
  });

  describe('helper functions', () => {
    it('should convert snake_case to PascalCase', () => {
      const result = service.pascalCase('user_profile');
      expect(result).toBe('UserProfile');
    });

    it('should convert snake_case to camelCase', () => {
      const result = service.camelCase('user_profile');
      expect(result).toBe('userProfile');
    });

    it('should map field types to Prisma types', () => {
      expect(service.prismaType('STRING')).toBe('String');
      expect(service.prismaType('INTEGER')).toBe('Int');
      expect(service.prismaType('BOOLEAN')).toBe('Boolean');
    });
  });
});
```

#### 1.2 文件生成服务测试
```typescript
// amis-backend-manager.service.spec.ts
describe('AmisBackendManagerService', () => {
  let service: AmisBackendManagerService;
  let configService: ConfigService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        AmisBackendManagerService,
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn().mockReturnValue('/tmp/test-amis-backend')
          }
        }
      ],
    }).compile();

    service = module.get<AmisBackendManagerService>(AmisBackendManagerService);
    configService = module.get<ConfigService>(ConfigService);
  });

  describe('writeGeneratedFiles', () => {
    it('should write files to correct locations', async () => {
      // Arrange
      const mockFiles: GeneratedFile[] = [
        {
          path: 'base/controllers/user.base.controller.ts',
          content: 'export class UserBaseController {}',
          type: 'base',
          overwrite: true
        },
        {
          path: 'biz/controllers/user.controller.ts',
          content: 'export class UserController {}',
          type: 'biz',
          overwrite: false
        }
      ];

      // Mock fs-extra
      const fsMock = {
        ensureDir: jest.fn().mockResolvedValue(undefined),
        pathExists: jest.fn().mockResolvedValue(false),
        writeFile: jest.fn().mockResolvedValue(undefined)
      };
      jest.doMock('fs-extra', () => fsMock);

      // Act
      await service.writeGeneratedFiles(mockFiles);

      // Assert
      expect(fsMock.ensureDir).toHaveBeenCalledTimes(2);
      expect(fsMock.writeFile).toHaveBeenCalledTimes(2);
    });

    it('should skip existing files when overwrite is false', async () => {
      const mockFiles: GeneratedFile[] = [
        {
          path: 'biz/controllers/user.controller.ts',
          content: 'export class UserController {}',
          type: 'biz',
          overwrite: false
        }
      ];

      const fsMock = {
        ensureDir: jest.fn().mockResolvedValue(undefined),
        pathExists: jest.fn().mockResolvedValue(true),
        writeFile: jest.fn().mockResolvedValue(undefined)
      };
      jest.doMock('fs-extra', () => fsMock);

      await service.writeGeneratedFiles(mockFiles);

      expect(fsMock.writeFile).not.toHaveBeenCalled();
    });
  });

  describe('generatePrismaSchema', () => {
    it('should generate valid Prisma schema', async () => {
      const mockMetadata = {
        entities: [
          {
            code: 'User',
            tableName: 'users',
            fields: [
              { code: 'id', type: 'STRING', primaryKey: true },
              { code: 'username', type: 'STRING', nullable: false }
            ]
          }
        ]
      };

      const fsMock = {
        readFile: jest.fn().mockResolvedValue('{{#each entities}}model {{code}} {}{{/each}}'),
        writeFile: jest.fn().mockResolvedValue(undefined)
      };
      jest.doMock('fs-extra', () => fsMock);

      await service.generatePrismaSchema(mockMetadata);

      expect(fsMock.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('prisma/schema.prisma'),
        expect.stringContaining('model User'),
        'utf8'
      );
    });
  });
});
```

### 2. API控制器测试

#### 2.1 代码生成控制器测试
```typescript
// code-generation.controller.spec.ts
describe('CodeGenerationController', () => {
  let controller: CodeGenerationController;
  let commandBus: CommandBus;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [CodeGenerationController],
      providers: [
        {
          provide: CommandBus,
          useValue: {
            execute: jest.fn()
          }
        }
      ],
    }).compile();

    controller = module.get<CodeGenerationController>(CodeGenerationController);
    commandBus = module.get<CommandBus>(CommandBus);
  });

  describe('generateCode', () => {
    it('should execute generate code command successfully', async () => {
      // Arrange
      const generateDto = {
        projectId: 'test-project-id',
        templateIds: ['template-1'],
        entityIds: ['entity-1'],
        outputPath: './output',
        variables: {},
        options: {
          overwriteExisting: true,
          generateTests: false,
          generateDocs: false,
          architecture: 'base-biz',
          framework: 'nestjs'
        }
      };

      const mockResult = {
        success: true,
        taskId: 'task-123',
        filesGenerated: 5,
        outputPath: './output',
        errors: [],
        warnings: []
      };

      jest.spyOn(commandBus, 'execute').mockResolvedValue(mockResult);

      // Act
      const result = await controller.generateCode(generateDto);

      // Assert
      expect(commandBus.execute).toHaveBeenCalledWith(
        expect.any(GenerateCodeCommand)
      );
      expect(result.status).toBe(0);
      expect(result.data.taskId).toBe('task-123');
    });

    it('should handle generation errors', async () => {
      const generateDto = {
        projectId: 'test-project-id',
        templateIds: ['template-1'],
        entityIds: ['entity-1'],
        outputPath: './output',
        variables: {},
        options: {
          overwriteExisting: true,
          generateTests: false,
          generateDocs: false,
          architecture: 'base-biz',
          framework: 'nestjs'
        }
      };

      jest.spyOn(commandBus, 'execute').mockRejectedValue(
        new Error('Generation failed')
      );

      await expect(controller.generateCode(generateDto))
        .rejects.toThrow('Generation failed');
    });
  });
});
```

## 🔗 集成测试规范

### 1. API集成测试

#### 1.1 代码生成API测试
```typescript
// code-generation.integration.spec.ts
describe('Code Generation API (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;

  beforeEach(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    prisma = moduleFixture.get<PrismaService>(PrismaService);
    
    await app.init();
    await setupTestDatabase();
  });

  afterEach(async () => {
    await cleanupTestDatabase();
    await app.close();
  });

  describe('POST /api/v1/code-generation/generate', () => {
    it('should generate code successfully', async () => {
      // Arrange
      const project = await createTestProject();
      const entity = await createTestEntity(project.id);
      const template = await createTestTemplate();

      const generateRequest = {
        projectId: project.id,
        templateIds: [template.id],
        entityIds: [entity.id],
        options: {
          overwriteExisting: true,
          generateTests: false,
          generateDocs: false,
          architecture: 'base-biz',
          framework: 'nestjs'
        }
      };

      // Act
      const response = await request(app.getHttpServer())
        .post('/api/v1/code-generation/generate')
        .send(generateRequest)
        .expect(200);

      // Assert
      expect(response.body.status).toBe(0);
      expect(response.body.data.taskId).toBeDefined();
      expect(response.body.data.filesGenerated).toBeGreaterThan(0);
    });

    it('should return error for invalid project', async () => {
      const generateRequest = {
        projectId: 'invalid-project-id',
        templateIds: ['template-1'],
        entityIds: ['entity-1'],
        options: {
          overwriteExisting: true,
          generateTests: false,
          generateDocs: false,
          architecture: 'base-biz',
          framework: 'nestjs'
        }
      };

      const response = await request(app.getHttpServer())
        .post('/api/v1/code-generation/generate')
        .send(generateRequest)
        .expect(400);

      expect(response.body.status).toBe(1);
      expect(response.body.msg).toContain('Project not found');
    });
  });

  describe('GET /api/v1/code-generation/progress/:taskId', () => {
    it('should return generation progress', async () => {
      // 先创建一个生成任务
      const taskId = await createGenerationTask();

      const response = await request(app.getHttpServer())
        .get(`/api/v1/code-generation/progress/${taskId}`)
        .expect(200);

      expect(response.body.status).toBe(0);
      expect(response.body.data.percentage).toBeDefined();
      expect(response.body.data.status).toBeDefined();
    });
  });
});
```

### 2. 数据库操作测试

#### 2.1 实体CRUD测试
```typescript
// entity.repository.integration.spec.ts
describe('EntityRepository Integration', () => {
  let repository: EntityRepository;
  let prisma: PrismaService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [PrismaModule],
      providers: [EntityRepository],
    }).compile();

    repository = module.get<EntityRepository>(EntityRepository);
    prisma = module.get<PrismaService>(PrismaService);
    
    await setupTestDatabase();
  });

  afterEach(async () => {
    await cleanupTestDatabase();
  });

  describe('create', () => {
    it('should create entity with fields', async () => {
      const project = await createTestProject();
      
      const entityData = {
        projectId: project.id,
        name: 'Test Entity',
        code: 'test_entity',
        tableName: 'test_entities',
        fields: [
          {
            name: 'Name',
            code: 'name',
            type: 'STRING',
            nullable: false
          }
        ]
      };

      const result = await repository.create(entityData);

      expect(result.id).toBeDefined();
      expect(result.name).toBe('Test Entity');
      expect(result.fields).toHaveLength(1);
    });
  });

  describe('findByProjectId', () => {
    it('should return entities for project', async () => {
      const project = await createTestProject();
      await createTestEntity(project.id, { name: 'Entity 1' });
      await createTestEntity(project.id, { name: 'Entity 2' });

      const result = await repository.findByProjectId(project.id);

      expect(result).toHaveLength(2);
      expect(result[0].name).toBe('Entity 1');
      expect(result[1].name).toBe('Entity 2');
    });
  });
});
```

## 🎭 E2E测试规范

### 1. 完整业务流程测试

#### 1.1 代码生成端到端测试
```typescript
// code-generation.e2e.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Code Generation E2E', () => {
  test.beforeEach(async ({ page }) => {
    // 登录系统
    await page.goto('/login');
    await page.fill('[data-testid=username]', 'admin');
    await page.fill('[data-testid=password]', 'password');
    await page.click('[data-testid=login-btn]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('complete code generation workflow', async ({ page }) => {
    // 1. 创建项目
    await page.goto('/lowcode/project');
    await page.click('[data-testid=add-project-btn]');
    
    await page.fill('[data-testid=project-name]', 'E2E Test Project');
    await page.fill('[data-testid=project-code]', 'e2e_test');
    await page.fill('[data-testid=project-description]', 'E2E测试项目');
    await page.click('[data-testid=save-btn]');
    
    await expect(page.locator('[data-testid=success-message]')).toBeVisible();

    // 2. 创建实体
    await page.goto('/lowcode/entity');
    await page.click('[data-testid=add-entity-btn]');
    
    await page.selectOption('[data-testid=project-select]', 'e2e_test');
    await page.fill('[data-testid=entity-name]', 'TestUser');
    await page.fill('[data-testid=entity-code]', 'test_user');
    await page.fill('[data-testid=table-name]', 'test_users');
    
    // 3. 添加字段
    await page.click('[data-testid=add-field-btn]');
    await page.fill('[data-testid=field-name]', 'Username');
    await page.fill('[data-testid=field-code]', 'username');
    await page.selectOption('[data-testid=field-type]', 'STRING');
    await page.uncheck('[data-testid=field-nullable]');
    await page.click('[data-testid=save-field-btn]');
    
    await page.click('[data-testid=add-field-btn]');
    await page.fill('[data-testid=field-name]', 'Email');
    await page.fill('[data-testid=field-code]', 'email');
    await page.selectOption('[data-testid=field-type]', 'STRING');
    await page.click('[data-testid=save-field-btn]');
    
    await page.click('[data-testid=save-entity-btn]');
    await expect(page.locator('[data-testid=success-message]')).toBeVisible();

    // 4. 生成代码
    await page.goto('/lowcode/code-generation');
    await page.selectOption('[data-testid=project-select]', 'e2e_test');
    
    // 等待实体加载
    await expect(page.locator('[data-testid=entity-test_user]')).toBeVisible();
    await page.check('[data-testid=entity-test_user]');
    
    // 选择模板
    await page.check('[data-testid=template-nestjs-crud]');
    
    // 配置选项
    await page.check('[data-testid=option-overwrite]');
    await page.selectOption('[data-testid=architecture-select]', 'base-biz');
    
    // 执行生成
    await page.click('[data-testid=generate-btn]');
    
    // 等待生成完成
    await expect(page.locator('[data-testid=generation-progress]')).toBeVisible();
    await expect(page.locator('[data-testid=generation-success]')).toBeVisible({ timeout: 30000 });
    
    // 验证生成结果
    const filesGenerated = await page.locator('[data-testid=files-generated]').textContent();
    expect(parseInt(filesGenerated)).toBeGreaterThan(0);

    // 5. 验证生成的API
    await page.goto('/lowcode/api-test');
    await page.selectOption('[data-testid=project-select]', 'e2e_test');
    await page.selectOption('[data-testid=api-select]', 'test_user');
    
    // 测试列表API
    await page.click('[data-testid=test-list-api]');
    await expect(page.locator('[data-testid=api-response]')).toContainText('"status": 0');
    
    // 测试创建API
    await page.click('[data-testid=test-create-api]');
    await page.fill('[data-testid=request-body]', JSON.stringify({
      username: 'testuser',
      email: 'test@example.com'
    }));
    await page.click('[data-testid=send-request]');
    await expect(page.locator('[data-testid=api-response]')).toContainText('"status": 0');
  });

  test('should handle generation errors gracefully', async ({ page }) => {
    await page.goto('/lowcode/code-generation');
    
    // 不选择项目直接生成
    await page.click('[data-testid=generate-btn]');
    
    // 应该显示错误信息
    await expect(page.locator('[data-testid=error-message]')).toBeVisible();
    await expect(page.locator('[data-testid=error-message]')).toContainText('请选择项目');
  });
});
```

## 📊 性能测试规范

### 1. 负载测试

#### 1.1 API性能测试
```typescript
// performance.spec.ts
describe('Performance Tests', () => {
  test('API response time should be under 200ms', async () => {
    const startTime = Date.now();
    
    const response = await request(app.getHttpServer())
      .get('/api/v1/entities')
      .expect(200);
    
    const responseTime = Date.now() - startTime;
    expect(responseTime).toBeLessThan(200);
  });

  test('should handle 100 concurrent requests', async () => {
    const promises = Array.from({ length: 100 }, () =>
      request(app.getHttpServer())
        .get('/api/v1/entities')
        .expect(200)
    );

    const results = await Promise.all(promises);
    expect(results).toHaveLength(100);
  });
});
```

## 🔧 测试工具配置

### Jest配置
```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/test'],
  testMatch: [
    '**/__tests__/**/*.test.ts',
    '**/?(*.)+(spec|test).ts'
  ],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/*.interface.ts',
    '!src/main.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 75,
      functions: 85,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/test/setup.ts']
};
```

### Playwright配置
```typescript
// playwright.config.ts
import { defineConfig } from '@playwright/test';

export default defineConfig({
  testDir: './test/e2e',
  timeout: 30000,
  retries: 2,
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    }
  ]
});
```

---

*本文档版本: v1.0*  
*最后更新: 2025-07-21*
