# ‰Ωé‰ª£Á†ÅÂπ≥Âè∞ÊµãËØïËßÑËåÉ

## üìã ÊµãËØïÁ≠ñÁï•

### ÊµãËØïÈáëÂ≠óÂ°î
```
    E2E Tests (10%)
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  Áî®Êà∑ÁïåÈù¢ÊµãËØï     ‚îÇ
   ‚îÇ  ‰∏öÂä°ÊµÅÁ®ãÊµãËØï     ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  
  Integration Tests (20%)
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ   APIÊé•Âè£ÊµãËØï        ‚îÇ
 ‚îÇ   ÊúçÂä°ÈõÜÊàêÊµãËØï       ‚îÇ
 ‚îÇ   Êï∞ÊçÆÂ∫ìÊìç‰ΩúÊµãËØï     ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Unit Tests (70%)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    ‰∏öÂä°ÈÄªËæëÊµãËØï          ‚îÇ
‚îÇ    Â∑•ÂÖ∑ÂáΩÊï∞ÊµãËØï          ‚îÇ
‚îÇ    Ê®°ÊùøÂºïÊìéÊµãËØï          ‚îÇ
‚îÇ    Êï∞ÊçÆÈ™åËØÅÊµãËØï          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ÊµãËØïË¶ÜÁõñÁéáË¶ÅÊ±Ç
- **ÂçïÂÖÉÊµãËØï**: ‚â•80%
- **ÈõÜÊàêÊµãËØï**: ‚â•70%
- **E2EÊµãËØï**: Ê†∏ÂøÉÊµÅÁ®ã100%
- **ÂàÜÊîØË¶ÜÁõñÁéá**: ‚â•75%
- **ÂáΩÊï∞Ë¶ÜÁõñÁéá**: ‚â•85%

## üß™ ÂçïÂÖÉÊµãËØïËßÑËåÉ

### 1. ‰ª£Á†ÅÁîüÊàêÂô®ÊµãËØï

#### 1.1 Ê®°ÊùøÂºïÊìéÊµãËØï
```typescript
// template-engine.service.spec.ts
describe('TemplateEngineService', () => {
  let service: TemplateEngineService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [TemplateEngineService],
    }).compile();

    service = module.get<TemplateEngineService>(TemplateEngineService);
  });

  describe('renderTemplate', () => {
    it('should render entity controller template correctly', async () => {
      // Arrange
      const templateName = 'entity-controller';
      const mockEntity = {
        code: 'user',
        name: 'Áî®Êà∑',
        fields: [
          { code: 'username', name: 'Áî®Êà∑Âêç', type: 'STRING' },
          { code: 'email', name: 'ÈÇÆÁÆ±', type: 'STRING' }
        ]
      };

      // Act
      const result = await service.renderTemplate(templateName, { entity: mockEntity });

      // Assert
      expect(result).toContain('@Controller(\'user\')');
      expect(result).toContain('export class UserController');
      expect(result).toContain('@Get()');
      expect(result).toContain('@Post()');
      expect(result).toContain('@Put(\':id\')');
      expect(result).toContain('@Delete(\':id\')');
    });

    it('should handle template variables correctly', async () => {
      const templateName = 'entity-model';
      const mockData = {
        entity: { code: 'test_entity', name: 'Test Entity' },
        fields: [
          { code: 'test_field', type: 'STRING', nullable: false }
        ]
      };

      const result = await service.renderTemplate(templateName, mockData);

      expect(result).toContain('TestEntity');
      expect(result).toContain('testField: string');
    });

    it('should throw error for non-existent template', async () => {
      await expect(service.renderTemplate('non-existent', {}))
        .rejects.toThrow('Template not found: non-existent');
    });
  });

  describe('helper functions', () => {
    it('should convert snake_case to PascalCase', () => {
      const result = service.pascalCase('user_profile');
      expect(result).toBe('UserProfile');
    });

    it('should convert snake_case to camelCase', () => {
      const result = service.camelCase('user_profile');
      expect(result).toBe('userProfile');
    });

    it('should map field types to Prisma types', () => {
      expect(service.prismaType('STRING')).toBe('String');
      expect(service.prismaType('INTEGER')).toBe('Int');
      expect(service.prismaType('BOOLEAN')).toBe('Boolean');
    });
  });
});
```

#### 1.2 Êñá‰ª∂ÁîüÊàêÊúçÂä°ÊµãËØï
```typescript
// amis-backend-manager.service.spec.ts
describe('AmisBackendManagerService', () => {
  let service: AmisBackendManagerService;
  let configService: ConfigService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        AmisBackendManagerService,
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn().mockReturnValue('/tmp/test-amis-backend')
          }
        }
      ],
    }).compile();

    service = module.get<AmisBackendManagerService>(AmisBackendManagerService);
    configService = module.get<ConfigService>(ConfigService);
  });

  describe('writeGeneratedFiles', () => {
    it('should write files to correct locations', async () => {
      // Arrange
      const mockFiles: GeneratedFile[] = [
        {
          path: 'base/controllers/user.base.controller.ts',
          content: 'export class UserBaseController {}',
          type: 'base',
          overwrite: true
        },
        {
          path: 'biz/controllers/user.controller.ts',
          content: 'export class UserController {}',
          type: 'biz',
          overwrite: false
        }
      ];

      // Mock fs-extra
      const fsMock = {
        ensureDir: jest.fn().mockResolvedValue(undefined),
        pathExists: jest.fn().mockResolvedValue(false),
        writeFile: jest.fn().mockResolvedValue(undefined)
      };
      jest.doMock('fs-extra', () => fsMock);

      // Act
      await service.writeGeneratedFiles(mockFiles);

      // Assert
      expect(fsMock.ensureDir).toHaveBeenCalledTimes(2);
      expect(fsMock.writeFile).toHaveBeenCalledTimes(2);
    });

    it('should skip existing files when overwrite is false', async () => {
      const mockFiles: GeneratedFile[] = [
        {
          path: 'biz/controllers/user.controller.ts',
          content: 'export class UserController {}',
          type: 'biz',
          overwrite: false
        }
      ];

      const fsMock = {
        ensureDir: jest.fn().mockResolvedValue(undefined),
        pathExists: jest.fn().mockResolvedValue(true),
        writeFile: jest.fn().mockResolvedValue(undefined)
      };
      jest.doMock('fs-extra', () => fsMock);

      await service.writeGeneratedFiles(mockFiles);

      expect(fsMock.writeFile).not.toHaveBeenCalled();
    });
  });

  describe('generatePrismaSchema', () => {
    it('should generate valid Prisma schema', async () => {
      const mockMetadata = {
        entities: [
          {
            code: 'User',
            tableName: 'users',
            fields: [
              { code: 'id', type: 'STRING', primaryKey: true },
              { code: 'username', type: 'STRING', nullable: false }
            ]
          }
        ]
      };

      const fsMock = {
        readFile: jest.fn().mockResolvedValue('{{#each entities}}model {{code}} {}{{/each}}'),
        writeFile: jest.fn().mockResolvedValue(undefined)
      };
      jest.doMock('fs-extra', () => fsMock);

      await service.generatePrismaSchema(mockMetadata);

      expect(fsMock.writeFile).toHaveBeenCalledWith(
        expect.stringContaining('prisma/schema.prisma'),
        expect.stringContaining('model User'),
        'utf8'
      );
    });
  });
});
```

### 2. APIÊéßÂà∂Âô®ÊµãËØï

#### 2.1 ‰ª£Á†ÅÁîüÊàêÊéßÂà∂Âô®ÊµãËØï
```typescript
// code-generation.controller.spec.ts
describe('CodeGenerationController', () => {
  let controller: CodeGenerationController;
  let commandBus: CommandBus;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [CodeGenerationController],
      providers: [
        {
          provide: CommandBus,
          useValue: {
            execute: jest.fn()
          }
        }
      ],
    }).compile();

    controller = module.get<CodeGenerationController>(CodeGenerationController);
    commandBus = module.get<CommandBus>(CommandBus);
  });

  describe('generateCode', () => {
    it('should execute generate code command successfully', async () => {
      // Arrange
      const generateDto = {
        projectId: 'test-project-id',
        templateIds: ['template-1'],
        entityIds: ['entity-1'],
        outputPath: './output',
        variables: {},
        options: {
          overwriteExisting: true,
          generateTests: false,
          generateDocs: false,
          architecture: 'base-biz',
          framework: 'nestjs'
        }
      };

      const mockResult = {
        success: true,
        taskId: 'task-123',
        filesGenerated: 5,
        outputPath: './output',
        errors: [],
        warnings: []
      };

      jest.spyOn(commandBus, 'execute').mockResolvedValue(mockResult);

      // Act
      const result = await controller.generateCode(generateDto);

      // Assert
      expect(commandBus.execute).toHaveBeenCalledWith(
        expect.any(GenerateCodeCommand)
      );
      expect(result.status).toBe(0);
      expect(result.data.taskId).toBe('task-123');
    });

    it('should handle generation errors', async () => {
      const generateDto = {
        projectId: 'test-project-id',
        templateIds: ['template-1'],
        entityIds: ['entity-1'],
        outputPath: './output',
        variables: {},
        options: {
          overwriteExisting: true,
          generateTests: false,
          generateDocs: false,
          architecture: 'base-biz',
          framework: 'nestjs'
        }
      };

      jest.spyOn(commandBus, 'execute').mockRejectedValue(
        new Error('Generation failed')
      );

      await expect(controller.generateCode(generateDto))
        .rejects.toThrow('Generation failed');
    });
  });
});
```

## üîó ÈõÜÊàêÊµãËØïËßÑËåÉ

### 1. APIÈõÜÊàêÊµãËØï

#### 1.1 ‰ª£Á†ÅÁîüÊàêAPIÊµãËØï
```typescript
// code-generation.integration.spec.ts
describe('Code Generation API (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;

  beforeEach(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    prisma = moduleFixture.get<PrismaService>(PrismaService);
    
    await app.init();
    await setupTestDatabase();
  });

  afterEach(async () => {
    await cleanupTestDatabase();
    await app.close();
  });

  describe('POST /api/v1/code-generation/generate', () => {
    it('should generate code successfully', async () => {
      // Arrange
      const project = await createTestProject();
      const entity = await createTestEntity(project.id);
      const template = await createTestTemplate();

      const generateRequest = {
        projectId: project.id,
        templateIds: [template.id],
        entityIds: [entity.id],
        options: {
          overwriteExisting: true,
          generateTests: false,
          generateDocs: false,
          architecture: 'base-biz',
          framework: 'nestjs'
        }
      };

      // Act
      const response = await request(app.getHttpServer())
        .post('/api/v1/code-generation/generate')
        .send(generateRequest)
        .expect(200);

      // Assert
      expect(response.body.status).toBe(0);
      expect(response.body.data.taskId).toBeDefined();
      expect(response.body.data.filesGenerated).toBeGreaterThan(0);
    });

    it('should return error for invalid project', async () => {
      const generateRequest = {
        projectId: 'invalid-project-id',
        templateIds: ['template-1'],
        entityIds: ['entity-1'],
        options: {
          overwriteExisting: true,
          generateTests: false,
          generateDocs: false,
          architecture: 'base-biz',
          framework: 'nestjs'
        }
      };

      const response = await request(app.getHttpServer())
        .post('/api/v1/code-generation/generate')
        .send(generateRequest)
        .expect(400);

      expect(response.body.status).toBe(1);
      expect(response.body.msg).toContain('Project not found');
    });
  });

  describe('GET /api/v1/code-generation/progress/:taskId', () => {
    it('should return generation progress', async () => {
      // ÂÖàÂàõÂª∫‰∏Ä‰∏™ÁîüÊàê‰ªªÂä°
      const taskId = await createGenerationTask();

      const response = await request(app.getHttpServer())
        .get(`/api/v1/code-generation/progress/${taskId}`)
        .expect(200);

      expect(response.body.status).toBe(0);
      expect(response.body.data.percentage).toBeDefined();
      expect(response.body.data.status).toBeDefined();
    });
  });
});
```

### 2. Êï∞ÊçÆÂ∫ìÊìç‰ΩúÊµãËØï

#### 2.1 ÂÆû‰ΩìCRUDÊµãËØï
```typescript
// entity.repository.integration.spec.ts
describe('EntityRepository Integration', () => {
  let repository: EntityRepository;
  let prisma: PrismaService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [PrismaModule],
      providers: [EntityRepository],
    }).compile();

    repository = module.get<EntityRepository>(EntityRepository);
    prisma = module.get<PrismaService>(PrismaService);
    
    await setupTestDatabase();
  });

  afterEach(async () => {
    await cleanupTestDatabase();
  });

  describe('create', () => {
    it('should create entity with fields', async () => {
      const project = await createTestProject();
      
      const entityData = {
        projectId: project.id,
        name: 'Test Entity',
        code: 'test_entity',
        tableName: 'test_entities',
        fields: [
          {
            name: 'Name',
            code: 'name',
            type: 'STRING',
            nullable: false
          }
        ]
      };

      const result = await repository.create(entityData);

      expect(result.id).toBeDefined();
      expect(result.name).toBe('Test Entity');
      expect(result.fields).toHaveLength(1);
    });
  });

  describe('findByProjectId', () => {
    it('should return entities for project', async () => {
      const project = await createTestProject();
      await createTestEntity(project.id, { name: 'Entity 1' });
      await createTestEntity(project.id, { name: 'Entity 2' });

      const result = await repository.findByProjectId(project.id);

      expect(result).toHaveLength(2);
      expect(result[0].name).toBe('Entity 1');
      expect(result[1].name).toBe('Entity 2');
    });
  });
});
```

## üé≠ E2EÊµãËØïËßÑËåÉ

### 1. ÂÆåÊï¥‰∏öÂä°ÊµÅÁ®ãÊµãËØï

#### 1.1 ‰ª£Á†ÅÁîüÊàêÁ´ØÂà∞Á´ØÊµãËØï
```typescript
// code-generation.e2e.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Code Generation E2E', () => {
  test.beforeEach(async ({ page }) => {
    // ÁôªÂΩïÁ≥ªÁªü
    await page.goto('/login');
    await page.fill('[data-testid=username]', 'admin');
    await page.fill('[data-testid=password]', 'password');
    await page.click('[data-testid=login-btn]');
    await expect(page).toHaveURL('/dashboard');
  });

  test('complete code generation workflow', async ({ page }) => {
    // 1. ÂàõÂª∫È°πÁõÆ
    await page.goto('/lowcode/project');
    await page.click('[data-testid=add-project-btn]');
    
    await page.fill('[data-testid=project-name]', 'E2E Test Project');
    await page.fill('[data-testid=project-code]', 'e2e_test');
    await page.fill('[data-testid=project-description]', 'E2EÊµãËØïÈ°πÁõÆ');
    await page.click('[data-testid=save-btn]');
    
    await expect(page.locator('[data-testid=success-message]')).toBeVisible();

    // 2. ÂàõÂª∫ÂÆû‰Ωì
    await page.goto('/lowcode/entity');
    await page.click('[data-testid=add-entity-btn]');
    
    await page.selectOption('[data-testid=project-select]', 'e2e_test');
    await page.fill('[data-testid=entity-name]', 'TestUser');
    await page.fill('[data-testid=entity-code]', 'test_user');
    await page.fill('[data-testid=table-name]', 'test_users');
    
    // 3. Ê∑ªÂä†Â≠óÊÆµ
    await page.click('[data-testid=add-field-btn]');
    await page.fill('[data-testid=field-name]', 'Username');
    await page.fill('[data-testid=field-code]', 'username');
    await page.selectOption('[data-testid=field-type]', 'STRING');
    await page.uncheck('[data-testid=field-nullable]');
    await page.click('[data-testid=save-field-btn]');
    
    await page.click('[data-testid=add-field-btn]');
    await page.fill('[data-testid=field-name]', 'Email');
    await page.fill('[data-testid=field-code]', 'email');
    await page.selectOption('[data-testid=field-type]', 'STRING');
    await page.click('[data-testid=save-field-btn]');
    
    await page.click('[data-testid=save-entity-btn]');
    await expect(page.locator('[data-testid=success-message]')).toBeVisible();

    // 4. ÁîüÊàê‰ª£Á†Å
    await page.goto('/lowcode/code-generation');
    await page.selectOption('[data-testid=project-select]', 'e2e_test');
    
    // Á≠âÂæÖÂÆû‰ΩìÂä†ËΩΩ
    await expect(page.locator('[data-testid=entity-test_user]')).toBeVisible();
    await page.check('[data-testid=entity-test_user]');
    
    // ÈÄâÊã©Ê®°Êùø
    await page.check('[data-testid=template-nestjs-crud]');
    
    // ÈÖçÁΩÆÈÄâÈ°π
    await page.check('[data-testid=option-overwrite]');
    await page.selectOption('[data-testid=architecture-select]', 'base-biz');
    
    // ÊâßË°åÁîüÊàê
    await page.click('[data-testid=generate-btn]');
    
    // Á≠âÂæÖÁîüÊàêÂÆåÊàê
    await expect(page.locator('[data-testid=generation-progress]')).toBeVisible();
    await expect(page.locator('[data-testid=generation-success]')).toBeVisible({ timeout: 30000 });
    
    // È™åËØÅÁîüÊàêÁªìÊûú
    const filesGenerated = await page.locator('[data-testid=files-generated]').textContent();
    expect(parseInt(filesGenerated)).toBeGreaterThan(0);

    // 5. È™åËØÅÁîüÊàêÁöÑAPI
    await page.goto('/lowcode/api-test');
    await page.selectOption('[data-testid=project-select]', 'e2e_test');
    await page.selectOption('[data-testid=api-select]', 'test_user');
    
    // ÊµãËØïÂàóË°®API
    await page.click('[data-testid=test-list-api]');
    await expect(page.locator('[data-testid=api-response]')).toContainText('"status": 0');
    
    // ÊµãËØïÂàõÂª∫API
    await page.click('[data-testid=test-create-api]');
    await page.fill('[data-testid=request-body]', JSON.stringify({
      username: 'testuser',
      email: 'test@example.com'
    }));
    await page.click('[data-testid=send-request]');
    await expect(page.locator('[data-testid=api-response]')).toContainText('"status": 0');
  });

  test('should handle generation errors gracefully', async ({ page }) => {
    await page.goto('/lowcode/code-generation');
    
    // ‰∏çÈÄâÊã©È°πÁõÆÁõ¥Êé•ÁîüÊàê
    await page.click('[data-testid=generate-btn]');
    
    // Â∫îËØ•ÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
    await expect(page.locator('[data-testid=error-message]')).toBeVisible();
    await expect(page.locator('[data-testid=error-message]')).toContainText('ËØ∑ÈÄâÊã©È°πÁõÆ');
  });
});
```

## üìä ÊÄßËÉΩÊµãËØïËßÑËåÉ

### 1. Ë¥üËΩΩÊµãËØï

#### 1.1 APIÊÄßËÉΩÊµãËØï
```typescript
// performance.spec.ts
describe('Performance Tests', () => {
  test('API response time should be under 200ms', async () => {
    const startTime = Date.now();
    
    const response = await request(app.getHttpServer())
      .get('/api/v1/entities')
      .expect(200);
    
    const responseTime = Date.now() - startTime;
    expect(responseTime).toBeLessThan(200);
  });

  test('should handle 100 concurrent requests', async () => {
    const promises = Array.from({ length: 100 }, () =>
      request(app.getHttpServer())
        .get('/api/v1/entities')
        .expect(200)
    );

    const results = await Promise.all(promises);
    expect(results).toHaveLength(100);
  });
});
```

## üîß ÊµãËØïÂ∑•ÂÖ∑ÈÖçÁΩÆ

### JestÈÖçÁΩÆ
```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/test'],
  testMatch: [
    '**/__tests__/**/*.test.ts',
    '**/?(*.)+(spec|test).ts'
  ],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/*.interface.ts',
    '!src/main.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 75,
      functions: 85,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/test/setup.ts']
};
```

### PlaywrightÈÖçÁΩÆ
```typescript
// playwright.config.ts
import { defineConfig } from '@playwright/test';

export default defineConfig({
  testDir: './test/e2e',
  timeout: 30000,
  retries: 2,
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] }
    }
  ]
});
```

---

*Êú¨ÊñáÊ°£ÁâàÊú¨: v1.0*  
*ÊúÄÂêéÊõ¥Êñ∞: 2025-07-21*
